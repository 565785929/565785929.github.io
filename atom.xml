<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2021-07-02T01:08:48+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[Pull Request]]></title>
    <link href="http://565785929.github.io/16251591834641.html"/>
    <updated>2021-07-02T01:06:23+08:00</updated>
    <id>http://565785929.github.io/16251591834641.html</id>
    <content type="html"><![CDATA[
<p>Pull Requests 是 Bitbucket 上方便开发者之间协作的功能。提供了一个用户友好的 Web 界面，在集成提交的变更到正式项目前可以对变更进行讨论。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158483461-ba62f737-e2ba-4e51-a349-9dcd5afc101e.png" alt=""/></p>

<p>开发者向团队成员通知功能开发已经完成，Pull Requests 是最简单的用法。开发者完成功能开发后，通过 Bitbucket 账号发起一个 Pull Request。这样让涉及这个功能的所有人知道，要去做 Code Review 和合并到 master 分支。</p>

<p>但是，Pull Request 远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。如果变更有任何问题，团队成员反馈在 Pull Request 中，甚至 push 新的提交微调功能。所有的这些活动都直接跟踪在 Pull Request 中。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158483888-8bd64e59-8356-47c4-8667-fb6e068e6ef5.png" alt=""/></p>

<p>相比其它的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。SVN 和 Git 都能通过一个简单的脚本收到通知邮件；但是，讨论变更时，开发者通常只能去回复邮件。这样做会变得杂乱，尤其还要涉及后面的几个提交时。Pull Requests 把所有相关功能整合到一个和 Bitbucket 仓库界面集成的用户友好 Web 界面中。</p>

<h2 id="toc_0">解析 Pull Request</h2>

<p>当要发起一个 Pull Request，你所要做的就是请求（Request）另一个开发者（比如项目的维护者），来 pull 你仓库中一个分支到他的仓库中。这意味着你要提供 4 个信息（源仓库、源分支、目的仓库、目的分支），以发起 Pull Request。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158484384-d3c053d7-3a76-4a9b-bf74-d21f95a85057.png" alt=""/></p>

<h2 id="toc_1">工作方式</h2>

<p>Pull Request 可以和功能分支工作流、GitFlow 工作流或 Forking 工作流一起使用。但 Pull Request 要求要么分支不同，要么仓库不同，所以不能用于集中式工作流。在不同的工作流中使用 Pull Request 会有一些不同，但基本的过程是这样的：</p>

<ul>
<li>  开发者在本地仓库中新建一个专门的分支开发功能。</li>
<li>  开发者 push 分支修改到公开的 Bitbucket 仓库中。</li>
<li>  开发者通过 Bitbucket 发起一个 Pull Request。</li>
<li>  团队的其它成员 review code，讨论并修改。</li>
<li>  项目维护者合并功能到官方仓库中并关闭 Pull Request。</li>
</ul>

<h3 id="toc_2">在功能分支工作流中使用 Pull Request</h3>

<p>功能分支工作流用一个共享的 Bitbucket 仓库来管理协作，开发者在专门的分支上开发功能。但不是立即合并到 master 分支上，而是在合并到主代码库之前开发者应该开一个 Pull Request 发起功能的讨论。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158484817-c40c39e1-5ce9-4ea2-a0d6-aad6f7512538.png" alt=""/></p>

<p>功能分支工作流只有一个公开的仓库，所以 Pull Request 的目的仓库和源仓库总是同一个。通常开发者会指定他的功能分支作为源分支，master 分支作为目的分支。</p>

<p>收到 Pull Request 后，项目维护者要决定如何做。如果功能没问题，就简单地合并到 master 分支，关闭 Pull Request。但如果提交的变更有问题，他可以在 Pull Request 中反馈。之后新加的提交也会评论之后接着显示出来</p>

<p>在功能还没有完全开发完的时候，也可能发起一个 Pull Request。比如开发者在实现某个需求时碰到了麻烦，他可以发一个包含正在进行中工作的 Pull Request。其它的开发者可以在 Pull Request 提供建议，或者甚至直接添加提交来解决问题。</p>

<h3 id="toc_3">在 GitFlow 工作流中使用 Pull Request</h3>

<p>GitFlow 工作流和功能分支工作流类似，但围绕项目发布定义一个严格的分支模型。在 GitFlow 工作流中使用 Pull Request 让开发者在发布分支或是维护分支上工作时，可以有个方便的地方对关于发布分支或是维护分支的问题进行交流。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158485321-cf385e8d-7386-45ec-8b9d-f66085d6afe7.png" alt=""/></p>

<p>GitFlow 工作流中 Pull Request 的使用过程和上一节中完全一致：当一个功能、发布或是热修复分支需要 Review 时，开发者简单发起一个 Pull Request，团队的其它成员会通过 Bitbucket 收到通知。</p>

<p>新功能一般合并到 develop 分支，而发布和热修复则要同时合并到 develop 分支和 master 分支上。Pull Request 可能用做所有合并的正式管理。</p>

<h3 id="toc_4">在 Forking 工作流中使用 Pull Request</h3>

<p>在 Forking 工作流中，开发者 push 完成的功能到他自己的仓库中，而不是共享仓库。然后，他发起一个 Pull Request，让项目维护者知道他的功能已经可以 Review 了。</p>

<p>在这个工作流，Pull Request 的通知功能非常有用，因为项目维护者不可能知道其它开发者在他们自己的仓库添加了提交</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158485734-a4503a38-b306-4823-a470-ca5bff990a30.png" alt=""/></p>

<p>由于各个开发有自己的公开仓库，Pull Request 的源仓库和目标仓库不是同一个。源仓库是开发者的公开仓库，源分支是包含了修改的分支。如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是 master 分支。</p>

<p>Pull Request 也可以用于正式项目之外的其它开发者之间的协作。比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个 Pull Request，用团队成员的 Bitbucket 仓库作为目标，而不是正式项目的仓库。然后使用相同的功能分支作为源和目标分支。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158486249-bddce86e-f304-45ba-ab5b-25175fba6a9f.png" alt=""/></p>

<p>2 个开发者之间可以在 Pull Request 中讨论和开发功能。完成开发后，他们可以发起另一个 Pull Request，请求合并功能到正式的 master 分支。在 Forking 工作流中，这样的灵活性让 Pull Request 成为一个强有力的协作工具。</p>

<h2 id="toc_5">示例</h2>

<p>下面的示例演示了 Pull Request 如何在在 Forking 工作流中使用。也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。</p>

<p>在示例中，小红是个开发，小明是项目维护者。他们各自有一个公开的 Bitbucket 仓库，而小明的仓库包含了正式工程。</p>

<h3 id="toc_6">小红 fork 正式项目</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158486621-9a5ddbfe-764b-4a19-b71c-7d2413886425.png" alt=""/></p>

<p>小红先要 fork 小明的 Bitbucket 仓库，开始项目的开发。她登陆 Bitbucket，浏览到小明的仓库页面，点 Fork 按钮。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158487094-d729b511-6383-44d3-be2f-d9116e1c9437.png" alt=""/></p>

<p>然后为 fork 出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。</p>

<h3 id="toc_7">小红克隆她的 Bitbucket 仓库</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158487582-221d2d6a-7556-4578-8995-625dbee7d63d.png" alt=""/></p>

<p>下一步，小红克隆自己刚才 fork 出来的 Bitbucket 仓库，以在本机上准备出工作拷贝。命令如下：</p>

<pre class="line-numbers"><code class="language-text">git clone https://user@bitbucket.org/user/repo.git 
</code></pre>

<p>1  </p>

<p>请记住，<code>git clone</code> 会自动创建 origin 远程别名，是指向小红 fork 出来的仓库。</p>

<h3 id="toc_8">小红开发新功能</h3>

<p>在开始改代码前，小红要为新功能先新建一个新分支。她会用这个分支作为 Pull Request 的源分支。</p>

<pre class="line-numbers"><code class="language-text">git checkout -b some-feature 
</code></pre>

<p>1  </p>

<h2 id="toc_9">编辑代码</h2>

<pre class="line-numbers"><code class="language-text">git commit -a -m &quot;Add first draft of some feature&quot; 
</code></pre>

<p>1  </p>

<p>在新功能分支上，小红按需要添加提交。甚至如果小红觉得功能分支上的提交历史太乱了，她可以用交互式 rebase 来删除或压制提交。对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在 Pull Request 中做了什么内容。</p>

<h3 id="toc_10">小红 push 功能到她的 Bitbucket 仓库中</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158488002-4e13947a-dbf0-486a-8123-2215c52bfd10.png" alt=""/></p>

<p>小红完成了功能后，push 功能到她自己的 Bitbucket 仓库中（不是正式仓库），用下面简单的命令：</p>

<pre class="line-numbers"><code class="language-text">git push origin some-branch 
</code></pre>

<p>1  </p>

<p>这时她的变更可以让项目维护者看到了（或者任何想要看的协作者）。</p>

<h3 id="toc_11">小红发起 Pull Request</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158488475-c7c41ee9-c699-4bd7-8eca-86dfb590ece0.png" alt=""/></p>

<p>Bitbucket 上有了她的功能分支后，小红可以用她的 Bitbucket 账号浏览到她的 fork 出来的仓库页面，点右上角的【Pull Request】按钮，发起一个 Pull Request。弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。</p>

<p>小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，而目标分支是 master 分支。另外，小红需要提供 Pull Request 的标题和描述信息。如果需要小明以外的人审核批准代码，她可以把这些人填在【Reviewers】文本框中。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158488939-9cad0ad8-dd34-46c4-8045-8644f02cdc0d.png" alt=""/></p>

<p>创建好了 Pull Request，通知会通过Bitbucket系统消息或邮件（可选）发给小明。</p>

<h3 id="toc_12">小明 review Pull Request</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158489479-4f21dd7f-614c-40a2-b35d-404f1ff54956.png" alt=""/></p>

<p>在小明的 Bitbucket 仓库页面的 【Pull Request】Tab 可以看到所有人发起的 Pull Request。点击小红的 Pull Request 会显示出 Pull Request 的描述、功能的提交历史和每个变更的差异（diff）。</p>

<p>如果小明想要合并到项目中，只要点一下【Merge】按钮，就可以同意 Pull Request 并合并到 master 分支。</p>

<p>但如果像这个示例中一样小明发现了在小红的代码中的一个小 Bug，要小红在合并前修复。小明可以在整个 Pull Request 上加上评注，或是选择历史中的某个提交加上评注。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158490024-43943919-5080-4e17-8442-8829d17db118.png" alt=""/></p>

<h3 id="toc_13">小红补加提交</h3>

<p>如果小红对反馈有任何疑问，可以在 Pull Request 中响应，把 Pull Request 当作是她功能讨论的论坛。</p>

<p>小红在她的功能分支新加提交以解决代码问题，并 push 到她的 Bitbucket 仓库中，就像前一轮中的做法一样。这些提交会进入的 Pull Request，小明在原来的评注旁边可以再次 review 变更。</p>

<h3 id="toc_14">小明接受 Pull Request</h3>

<p>最终，小明接受变更，合并功能分支到 master 分支，并关闭 Pull Request。至此，功能集成到项目中，其它的项目开发者可以用标准的 git pull 命令 pull 这些变更到自己的本地仓库中。</p>

<h2 id="toc_15">总结</h2>

<p>到了这里，你应该有了所有需要的工具来集成 Pull Request 到你自己的工作流。请记住，Pull Request 并不是为了替代任何基于 Git 的协作工作流，而是它们的一个便利的补充，让团队成员间的协作更轻松方便。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forking 工作流]]></title>
    <link href="http://565785929.github.io/16251591565160.html"/>
    <updated>2021-07-02T01:05:56+08:00</updated>
    <id>http://565785929.github.io/16251591565160.html</id>
    <content type="html"><![CDATA[
<p>Forking 工作流和前面讨论的几种工作流有根本的不同。这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有 2 个 Git 仓库而不是 1 个：一个本地私有的，另一个服务端公开的。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158462371-9a14f3f0-4337-476b-8676-25dc8b4f0fae.png" alt=""/></p>

<p>Forking 工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能 push 代码到仅有的中央仓库中。开发者 push 到自己的服务端仓库，而只有项目维护者才能 push 到正式仓库。这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。</p>

<p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。也让这个工作流成为开源项目的理想工作流。</p>

<h2 id="toc_0">工作方式</h2>

<p>和其它的 Git 工作流一样，Forking 工作流要先有一个公开的正式仓库存储在服务器上。但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是 fork 正式项目在服务器上创建一个拷贝。</p>

<p>这个仓库拷贝作为他个人公开仓库 —— 其它开发者不允许 push 到这个仓库，但可以 pull 到修改（后面我们很快就会看这点很重要）。在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行 git clone 命令克隆仓库到本地机器上，作为私有的开发环境。</p>

<p>要提交本地修改时，push 提交到自己公开仓库中 —— 而不是正式仓库中。然后，给正式仓库发起一个 pull request，让项目维护者知道有更新已经准备好可以集成了。对于贡献的代码，pull request 也可以很方便地作为一个讨论的地方。</p>

<p>为了集成功能到正式代码库，维护者 pull 贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，合并变更到自己本地的 master 分支，然后 push master 分支到服务器的正式仓库中。到此，贡献的提交成为了项目的一部分，其它的开发者应该执行 pull 操作与正式仓库同步自己本地仓库。</p>

<h3 id="toc_1">正式仓库</h3>

<p>在 Forking 工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。从技术上来看，各个开发者仓库和正式仓库在Git看来没有任何区别。事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。</p>

<h3 id="toc_2">Forking 工作流的分支使用方式</h3>

<p>所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。各个开发者应该用分支隔离各个功能，就像在功能分支工作流和 GitFlow 工作流一样。唯一的区别是这些分支被共享了。在 Forking 工作流中这些分支会被 pull 到另一个开发者的本地仓库中，而在功能分支工作流和 GitFlow 工作流中是直接被 push 到正式仓库中。</p>

<h2 id="toc_3">示例</h2>

<h3 id="toc_4">项目维护者初始化正式仓库</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158462737-3f108c47-e5d7-463b-96ad-97cb7c82f8d2.png" alt=""/></p>

<p>和任何使用 Git 项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。通常这个仓库也会作为项目维护者的公开仓库。</p>

<p>公开仓库应该是裸仓库，不管是不是正式代码库。所以项目维护者会运行像下面的命令来搭建正式仓库：</p>

<pre class="line-numbers"><code class="language-text">ssh user@host
git init --bare /path/to/repo.git 
</code></pre>

<p>1<br/><br/>
2  </p>

<p>Bitbucket 和 Stash 提供了一个方便的 GUI 客户端以完成上面命令行做的事。这个搭建中央仓库的过程和前面提到的工作流完全一样。如果有现存的代码库，维护者也要 push 到这个仓库中。</p>

<h3 id="toc_5">开发者 fork 正式仓库</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158463221-fedae533-07f3-45d5-adca-8cdbeaaf5384.png" alt=""/></p>

<p>其它所有的开发需要 fork 正式仓库。可以用 git clone 命令用 SSH 协议连通到服务器，拷贝仓库到服务器另一个位置 —— 是的，fork 操作基本上就只是一个服务端的克隆。Bitbucket 和 Stash 上可以点一下按钮就让开发者完成仓库的 fork 操作。</p>

<p>这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。</p>

<h3 id="toc_6">开发者克隆自己 fork 出来的仓库</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158463895-89876699-dc65-4548-b1d9-9b41251c76e5.png" alt=""/></p>

<p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的 git clone 命令。</p>

<p>在这个示例中，假定用 Bitbucket 托管了仓库。记住，如果这样的话各个开发者需要有各自的 Bitbucket 账号，使用下面命令克隆服务端自己的仓库：</p>

<pre class="line-numbers"><code class="language-text">git clone https://user@bitbucket.org/user/repo.git 
</code></pre>

<p>1  </p>

<p>相比前面介绍的工作流只用了一个 origin 远程别名指向中央仓库，Forking 工作流需要 2 个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用 origin 作为远程克隆的仓库的别名（这个别名会在运行 git clone 自动创建），upstream（上游）作为正式仓库的别名。</p>

<pre class="line-numbers"><code class="language-text">git remote add upstream https://bitbucket.org/maintainer/repo 
</code></pre>

<p>1  </p>

<p>需要自己用上面的命令创建 upstream 别名。这样可以简单地保持本地仓库和正式仓库的同步更新。注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：</p>

<pre class="line-numbers"><code class="language-text">git remote add upstream https://user@bitbucket.org/maintainer/repo.git 
</code></pre>

<p>1  </p>

<p>这时在克隆和 pull 正式仓库时，需要提供用户的密码。</p>

<h3 id="toc_7">开发者开发自己的功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158464322-60a35455-80b7-4c43-b5a2-1bb238f597df.png" alt=""/></p>

<p>在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、提交修改和新建分支：</p>

<pre class="line-numbers"><code class="language-text">git checkout -b some-feature
// Edit some code
git commit -a -m &quot;Add first draft of some feature&quot; 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3  </p>

<p>所有的修改都是私有的直到 push 到自己公开仓库中。如果正式项目已经往前走了，可以用 git pull 命令获得新的提交：</p>

<pre class="line-numbers"><code class="language-text">git pull upstream master 
</code></pre>

<p>1  </p>

<p>由于开发者应该都在专门的功能分支上工作，pull 操作结果会都是快进合并。</p>

<h3 id="toc_8">开发者发布自己的功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158464748-1e24500e-a0c3-49ac-ba52-581192dc754f.png" alt=""/></p>

<p>一旦开发者准备好了分享新功能，需要做二件事。首先，通过push他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。他的 origin 远程别名应该已经有了，所以要做的就是：</p>

<pre class="line-numbers"><code class="language-text">git push origin feature-branch 
</code></pre>

<p>1  </p>

<p>这里和之前的工作流的差异是，origin 远程别名指向开发者自己的服务端仓库，而不是正式仓库。</p>

<p>第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。Bitbucket 和 Stash 提供了 Pull Request 按钮，弹出表单让你指定哪个分支要合并到正式仓库。一般你会想集成你的功能分支到上游远程仓库的 master 分支中。</p>

<h3 id="toc_9">项目维护者集成开发者的功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158465114-7f8d4792-8892-4c97-82c2-355d526f64aa.png" alt=""/></p>

<p>当项目维护者收到 pull request，他要做的是决定是否集成它到正式代码库中。有二种方式来做：</p>

<ul>
<li>  直接在 pull request 中查看代码</li>
<li>  pull 代码到他自己的本地仓库，再手动合并</li>
</ul>

<p>第一种做法更简单，维护者可以在 GUI 中查看变更的差异，做评注和执行合并。但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中 fetch 功能分支，合并到他本地的 master 分支，解决冲突：</p>

<pre class="line-numbers"><code class="language-text">git fetch https://bitbucket.org/user/repo feature-branch
// 查看变更
git checkout master
git merge FETCH_HEAD 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4  </p>

<p>变更集成到本地的 master 分支后，维护者要 push 变更到服务器上的正式仓库，这样其它的开发者都能访问到：</p>

<p>注意，维护者的 origin 是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中</p>

<h3 id="toc_10">开发者和正式仓库做同步</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158465571-281df3e5-7964-4848-b7f7-1642cdc0e7f3.png" alt=""/></p>

<p>由于正式代码库往前走了，其它的开发需要和正式仓库做同步：</p>

<pre class="line-numbers"><code class="language-text">git pull upstream master 
</code></pre>

<p>1  </p>

<h2 id="toc_11">总结</h2>

<p>如果你之前是使用 SVN，Forking 工作流可能看起来像是一个激进的范式切换（paradigm shift）。但不要害怕，这个工作流实际上就是在功能分支工作流之上引入另一个抽象层。不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。</p>

<p>示例中解释了，一个贡献如何从一个开发者流到正式的 master 分支中，但同样的方法可以把贡献集成到任一个仓库中。比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。</p>

<p>这使得 Forking 工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitFlow 工作流]]></title>
    <link href="http://565785929.github.io/16251591321661.html"/>
    <updated>2021-07-02T01:05:32+08:00</updated>
    <id>http://565785929.github.io/16251591321661.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">本节视频</h2>

<ul>
<li>  <a href="https://www.bilibili.com/video/av32573821/">【视频】Git工作流指南-GitFlow工作流</a></li>
</ul>

<h2 id="toc_1">概述</h2>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158440035-3205d6ad-53eb-48f7-aa81-d9176fb1989a.png" alt=""/></p>

<p>GitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p>

<p>GitFlow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。</p>

<h2 id="toc_2">工作方式</h2>

<p>GitFlow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到中央仓库中。</p>

<h3 id="toc_3">历史分支</h3>

<p>相对使用仅有的一个 master 分支，GitFlow 工作流使用2个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。这样也方便 master 分支上的所有提交分配一个版本号。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158440579-413df074-5083-4235-9f9f-106c68ad4bc8.png" alt=""/></p>

<p>剩下要说明的问题围绕着这2个分支的区别展开。</p>

<h3 id="toc_4">功能分支</h3>

<p>每个新功能位于一个自己的分支，这样可以 push 到中央仓库以备份和协作。但功能分支不是从 master 分支上拉出新分支，而是使用 develop 分支作为父分支。当新功能完成时，合并回 develop 分支。新功能提交应该从不直接与 master 分支交互。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158441115-51867377-df20-4a40-9977-670764628bbc.png" alt=""/></p>

<p>注意，从各种含义和目的上来看，功能分支加上 develop 分支就是功能分支工作流的用法。但 GitFlow 工作流没有在这里止步。</p>

<h3 id="toc_5">发布分支</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158441688-d9d993b0-0ed1-46bd-a100-2cce18078355.png" alt=""/></p>

<p>一旦 develop 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 develop 分支上 fork 一个发布分支。新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上 —— 这个分支只应该做 Bug 修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到 master 分支并分配一个版本号打好 Tag。另外，这些从新建发布分支以来的做的修改要合并回 develop 分支。</p>

<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本 4.0』，并且在仓库的目录结构中可以实际看到）。</p>

<p>常用的分支约定：</p>

<ul>
<li>  用于新建发布分支的分支: develop</li>
<li>  用于合并的分支: master</li>
<li>  分支命名: release-* 或 release/*</li>
</ul>

<h3 id="toc_6">维护分支</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158442511-25ceae74-7a3a-49a8-8792-98efd525963e.png" alt=""/></p>

<p>维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从 master 分支 fork 出来的分支。修复完成，修改应该马上合并回 master 分支和 develop 分支（当前的发布分支），master 分支应该用新的版本号打好 Tag。</p>

<p>为 Bug 修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。你可以把维护分支想成是一个直接在 master 分支上处理的临时发布。</p>

<h2 id="toc_7">示例</h2>

<p>下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。</p>

<h3 id="toc_8">创建开发分支</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158443044-99a89992-8b38-4aaf-b002-b15dd56df75c.png" alt=""/></p>

<p>第一步为 master 分支配套一个 develop 分支。简单来做可以本地创建一个空的 develop 分支，push 到服务器上：</p>

<pre class="line-numbers"><code class="language-text">git branch develop
git push -u origin develop 
</code></pre>

<p>1<br/><br/>
2  </p>

<p>以后这个分支将会包含了项目的全部历史，而 master 分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好 develop 分支的跟踪分支：</p>

<pre class="line-numbers"><code class="language-text">git clone ssh://user@host/path/to/repo.git
git checkout -b develop origin/develop 
</code></pre>

<p>1<br/><br/>
2  </p>

<p>现在每个开发都有了这些历史分支的本地拷贝。</p>

<h3 id="toc_9">小红和小明开始开发新功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158443710-f4ade559-f84a-42e4-ac8d-3d0f22248081.png" alt=""/></p>

<p>这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于 master 分支，而是应该基于 develop 分支：</p>

<pre class="line-numbers"><code class="language-text">git checkout -b some-feature develop 
</code></pre>

<p>1  </p>

<p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：</p>

<pre class="line-numbers"><code class="language-text">git status
git add
git commit 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3  </p>

<h3 id="toc_10">小红完成功能开发</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158444380-78d93af4-16f5-4141-bdb1-7156f5647b51.png" alt=""/></p>

<p>添加了提交后，小红觉得她的功能 OK 了。如果团队使用 Pull Requests，这时候可以发起一个用于合并到 develop 分支。否则她可以直接合并到她本地的 develop 分支后 push 到中央仓库：</p>

<pre class="line-numbers"><code class="language-text">git pull origin develop
git checkout develop
git merge some-feature
git push
git branch -d some-feature 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5  </p>

<p>第一条命令在合并功能前确保 develop 分支是最新的。注意，功能决不应该直接合并到 master 分支。冲突解决方法和集中式工作流一样。</p>

<h3 id="toc_11">小红开始准备发布</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158445152-45f9dd4d-79d7-4f45-9051-498f586229ba.png" alt=""/></p>

<p>这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：</p>

<pre class="line-numbers"><code class="language-text">git checkout -b release-0.1 develop 
</code></pre>

<p>1  </p>

<p>这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。</p>

<p>只要小红创建这个分支并 push 到中央仓库，这个发布就是功能冻结的。任何不在 develop 分支中的新功能都推到下个发布循环中。</p>

<h3 id="toc_12">小红完成发布</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158445817-eb9f7c52-8a1c-4d2a-a41d-0037cf489ec2.png" alt=""/></p>

<p>一旦准备好了对外发布，小红合并修改到 master 分支和 develop 分支上，删除发布分支。合并回 develop 分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。另外，如果小红的团队要求 Code Review，这是一个发起 Pull Request 的理想时机。</p>

<pre class="line-numbers"><code class="language-text">git checkout master
git merge release-0.1
git push
git checkout develop
git merge release-0.1
git push
git branch -d release-0.1 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5<br/><br/>
6<br/><br/>
7  </p>

<p>发布分支是作为功能开发（develop 分支）和对外发布（master 分支）间的缓冲。只要有合并到 master 分支，就应该打好 Tag 以方便跟踪。</p>

<pre class="line-numbers"><code class="language-text">git tag -a 0.1 -m &quot;Initial public release&quot; master
git push --tags 
</code></pre>

<p>1<br/><br/>
2  </p>

<p>Git 有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。可以配置一个勾子，在你 push 中央仓库的 master 分支时，自动构建好对外发布。</p>

<h3 id="toc_13">最终用户发现 Bug</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158446176-19ac3d5a-4b3b-41e8-b7e0-e381d65f1304.png" alt=""/></p>

<p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个 Ticket 抱怨当前版本的一个 Bug。为了处理 Bug，小红（或小明）从 master 分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回 master 分支：</p>

<pre class="line-numbers"><code class="language-text">git checkout -b issue-#001 master
# Fix the bug
git checkout master
git merge issue-#001
git push 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5  </p>

<p>就像发布分支，维护分支中新加这些重要修改需要包含到 develop 分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了：</p>

<pre class="line-numbers"><code class="language-text">git checkout develop
git merge issue-#001
git push
git branch -d issue-#001 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4  </p>

<h2 id="toc_14">总结</h2>

<p>到了这里，但愿你对集中式工作流、功能分支工作流和 GitFlow 工作流已经感觉很舒适了。你应该也牢固的掌握了本地仓库的潜能，push/pull 模式和 Git 健壮的分支和合并模型。</p>

<p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用 Git 不可违逆的条例。所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让 Git 为你所用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[功能分支工作流]]></title>
    <link href="http://565785929.github.io/16251589603172.html"/>
    <updated>2021-07-02T01:02:40+08:00</updated>
    <id>http://565785929.github.io/16251589603172.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">本节视频</h2>

<ul>
<li>  <a href="https://www.bilibili.com/video/av32568096/">【视频】Git工作流指南-功能分支工作流</a></li>
</ul>

<h2 id="toc_1">概述</h2>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158420059-25a04350-f8ff-4796-b558-1c3e8a2a5d4c.png" alt=""/></p>

<p>一旦你玩转了集中式工作流，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。</p>

<p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在 master 分支上。这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。另外，也保证了 master 分支的代码一定不会是有问题的，极大有利于集成环境。</p>

<p>功能开发隔离也让 pull requests 工作流成功可能，pull requests 工作流能为每个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。另外，如果你在功能开发中有问题卡住了，可以开一个 pull requests 来向同学们征求建议。这些做法的重点就是，pull requests 让团队成员之间互相评论工作变成非常方便！</p>

<h2 id="toc_2">工作方式</h2>

<p>功能分支工作流仍然用中央仓库，并且 master 分支还是代表了正式项目的历史。但不是直接提交本地历史到各自的本地 master 分支，开发者每次在开始新功能前先创建一个新分支。功能分支应该有个有描述性的名字，比如 animated-menu-items 或 issue-#1061，这样可以让分支有个清楚且高聚焦的用途。</p>

<p>在 master 分支和功能分支之间，Git 是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。</p>

<p>另外，功能分支也可以（且应该）push 到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。由于 master 仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题。当然，这样做也可以很方便地备份各自的本地提交。</p>

<h2 id="toc_3">Pull Requests</h2>

<p>功能分支除了可以隔离功能的开发，也使得通过 Pull Requests 讨论变更成为可能。一旦某个开发完成一个功能，不是立即合并到 master，而是 push 到中央仓库的功能分支上并发起一个 Pull Request 请求去合并修改到 master。在修改成为主干代码前，这让其它的开发者有机会先去 Review 变更。</p>

<p>Code Review 是 Pull Requests 的一个重要的收益，但 Pull Requests 目的是讨论代码一个通用方式。你可以把 Pull Requests 作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行 Code Review。比如，一个开发者开发功能需要帮助时，要做的就是发起一个 Pull Request，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。</p>

<p>一旦 Pull Request 被接受了，发布功能要做的就和集中式工作流就很像了。首先，确定本地的 master 分支和上游的 master 分支是同步的。然后合并功能分支到本地 master 分支并 push 已经更新的本地 master 分支到中央仓库。</p>

<h2 id="toc_4">示例</h2>

<p>下面的示例演示了如何把 Pull Requests 作为 Code Review 的方式，但注意 Pull Requests 可以用于很多其它的目的。</p>

<h3 id="toc_5">小红开始开发一个新功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158420507-cb68aa3a-a68b-4f09-b619-1dfd1f7a8f73.png" alt=""/></p>

<p>在开始开发功能前，小红需要一个独立的分支。使用下面的命令新建一个分支：</p>

<pre class="line-numbers"><code class="language-text">git checkout -b marys-feature master 
</code></pre>

<p>1  </p>

<p>这个命令检出一个基于 master 名为 marys-feature 的分支，Git 的 <code>-b</code> 选项表示如果分支还不存在则新建分支。这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能：</p>

<pre class="line-numbers"><code class="language-text">git status
git add
git commit 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3  </p>

<h3 id="toc_6">小红要去吃个午饭</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158420926-4fbd62ca-8b53-475a-8070-f211d791d4a3.png" alt=""/></p>

<p>早上小红为新功能添加一些提交。去吃午饭前，push 功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到小红的提交。</p>

<pre class="line-numbers"><code class="language-text">git push -u origin marys-feature 
</code></pre>

<p>1  </p>

<p>这条命令 <code>push marys-feature</code> 分支到中央仓库（origin），<code>-u</code> 选项设置本地分支去跟踪远程对应的分支。设置好跟踪的分支后，小红就可以使用 <code>git push</code> 命令省去指定推送分支的参数。</p>

<h3 id="toc_7">小红完成功能开发</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158421347-90a6cb4c-fbc0-4c83-a268-b4628dff59b6.png" alt=""/></p>

<p>小红吃完午饭回来，完成整个功能的开发。在合并到 master 之前，她发起一个 Pull Request 让团队的其它人知道功能已经完成。但首先，她要确认中央仓库中已经有她最近的提交：</p>

<p>然后，在她的 Git GUI 客户端中发起 Pull Request，请求合并 marys-feature 到 master，团队成员会自动收到通知。Pull Request 很酷的是可以在相关的提交旁边显示评注，所以你可以很对某个变更集提问。</p>

<h3 id="toc_8">小黑收到 Pull Request</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158421745-37f3b3d3-e422-4966-a168-fe22187e47c4.png" alt=""/></p>

<p>小黑收到了 Pull Request 后会查看 marys-feature 的修改。决定在合并到正式项目前是否要做些修改，且通过 Pull Request 和小红来回地讨论。</p>

<h3 id="toc_9">小红再做修改</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158422158-ad604867-f8e9-4853-9ea5-e1fea85266b3.png" alt=""/></p>

<p>要再做修改，小红用和功能第一个迭代完全一样的过程。编辑、暂存、提交并push更新到中央仓库。小红这些活动都会显示在 Pull Request 上，小黑可以断续做评注。</p>

<p>如果小黑有需要，也可以把 marys-feature 分支拉到本地，自己来修改，他加的提交也会一样显示在 Pull Request 上。</p>

<h3 id="toc_10">小红发布她的功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158422563-822e9285-34ed-4a53-89fb-4cec2b42dc99.png" alt=""/></p>

<p>一旦小黑可以的接受 Pull Request，就可以合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）：</p>

<pre class="line-numbers"><code class="language-text">git checkout master
git pull
git pull origin marys-feature
git push 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4  </p>

<p>无论谁来做合并，首先要检出 master 分支并确认是它是最新的。然后执行 <code>git pull origin marys-feature</code> 合并 marys-feature 分支到和已经和远程一致的本地 master 分支。你可以使用简单 <code>git merge marys-feature</code> 命令，但前面的命令可以保证总是最新的新功能分支。最后更新的 master 分支要重新 push 回到 origin。</p>

<p>这个过程常常会生成一个合并提交。有些开发者喜欢有合并提交，因为它像一个新功能和原来代码基线的连通符。但如果你偏爱线性的提交历史，可以在执行合并时 rebase 新功能到 master 分支的顶部，这样生成一个快进（fast-forward）的合并。</p>

<p>一些 GUI 客户端可以只要点一下『接受』按钮执行好上面的命令来自动化 Pull Request 接受过程。如果你的不能这样，至少在功能合并到 master 分支后能自动关闭 Pull Request。</p>

<h3 id="toc_11">与此同时，小明在做和小红一样的事</h3>

<p>当小红和小黑在 marys-feature 上工作并讨论她的 Pull Request 的时候，小明在自己的功能分支上做完全一样的事。</p>

<p>通过隔离功能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。</p>

<h2 id="toc_12">总结</h2>

<p>到了这里，但愿你发现了功能分支可以很直接地在集中式工作流的仅有的 master 分支上完成多功能的开发。另外，功能分支还使用了 Pull Request，使得可以在你的版本控制 GUI 客户端中讨论某个提交。</p>

<p>功能分支工作流是开发项目异常灵活的方式。问题是，有时候太灵活了。对于大型团队，常常需要给不同分支分配一个更具体的角色。GitFlow 工作流是管理功能开发、发布准备和维护的常用模式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集中式工作流]]></title>
    <link href="http://565785929.github.io/16251585082271.html"/>
    <updated>2021-07-02T00:55:08+08:00</updated>
    <id>http://565785929.github.io/16251585082271.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0"></h1>

<h2 id="toc_1"><a href="#%E6%9C%AC%E8%8A%82%E8%A7%86%E9%A2%91">#</a> 本节视频</h2>

<ul>
<li>  <a href="https://www.bilibili.com/video/av32563618/">【视频】Git工作流指南-集中式工作流</a></li>
</ul>

<h2 id="toc_2"><a href="#%E6%A6%82%E8%BF%B0">#</a> 概述</h2>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158392279-4bd0d508-179d-41ac-a42a-e196c20a535e.png" alt=""/></p>

<p>转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上 Git 带来的收益。团队可以用和 Subversion 完全不变的方式来开发项目。</p>

<p>但使用 Git 加强开发的工作流，Git 比 SVN 有几个优势。首先，每个开发可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分（修改）独立开来 —— 即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。</p>

<p>其次，Git 提供了强壮的分支和合并模型。不像 SVN，Git 的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。</p>

<h2 id="toc_3"><a href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">#</a> 工作方式</h2>

<p>像 Subversion 一样，集中式工作流以中央仓库作为项目所有修改的单点实体。相比 SVN 缺省的开发分支 trunk，Git 叫做 master，所有修改提交到这个分支上。该工作流只用到 master 这一个分支。</p>

<p>开发者开始先克隆中央仓库。在自己的项目拷贝中，像 SVN 一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。</p>

<p>要发布修改到正式项目中，开发者要把本地 master 分支的修改『推（<code>push</code>）』到中央仓库中。这相当于 svn commit 操作，但 <code>push</code> 操作会把所有还不在中央仓库的本地提交都推上去。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158392648-509e90f8-c8fe-46a6-be99-2bad4fa78ae2.png" alt=""/></p>

<h2 id="toc_4"><a href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81">#</a> 解决冲突</h2>

<p>中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。如果开发者本地的提交历史和中央仓库有分歧，Git 会拒绝 <code>push</code> 提交否则会覆盖已经在中央库的正式提交。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158393097-a3f96fbd-6d57-4771-9f8f-155a3874d17a.png" alt=""/></p>

<p>在开发者提交自己功能修改到中央库前，需要先 <code>fetch</code> 在中央库的新增提交，<code>rebase</code> 自己提交到中央库提交历史之上。这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的<code>SVN</code> 的工作流中一样。</p>

<p>如果本地修改和上游提交有冲突，Git 会暂停 <code>rebase</code> 过程，给你手动解决冲突的机会。Git 解决合并冲突，用和生成提交一样的 <code>git status</code> 和 <code>git add</code> 命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，Git 可以很简单中止整个 <code>rebase</code> 操作，重来一次（或者让别人来帮助解决）。</p>

<h2 id="toc_5"><a href="#%E7%A4%BA%E4%BE%8B">#</a> 示例</h2>

<p>让我们一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。</p>

<h3 id="toc_6"><a href="#%E6%9C%89%E4%BA%BA%E5%85%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%BD%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93">#</a> 有人先初始化好中央仓库</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158393542-4b51f15b-0d5a-4757-a83c-23edf85690bc.png" alt=""/></p>

<p>第一步，有人在服务器上创建好中央仓库。如果是新项目，你可以初始化一个空仓库；否则你要导入已有的 Git 或 SVN 仓库。</p>

<p>中央仓库应该是个裸仓库（bare repository），即没有工作目录（working directory）的仓库。</p>

<h3 id="toc_7"><a href="#%E6%89%80%E6%9C%89%E4%BA%BA%E5%85%8B%E9%9A%86%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93">#</a> 所有人克隆中央仓库</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158394016-075364b4-831b-44b4-90f8-0c9678673607.png" alt=""/></p>

<p>下一步，各个开发者创建整个项目的本地拷贝。通过 <code>git clone</code> 命令完成：</p>

<pre class="line-numbers"><code class="language-text">git clone https://github.com/path/to/repo.git 
</code></pre>

<p>1  </p>

<p>基于你后续会持续和克隆的仓库做交互的假设，克隆仓库时 Git 会自动添加远程别名 origin 指回『父』仓库。</p>

<h3 id="toc_8"><a href="#%E5%B0%8F%E6%98%8E%E5%BC%80%E5%8F%91%E5%8A%9F%E8%83%BD">#</a> 小明开发功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158394403-d13b3b64-8160-43f7-8077-3a1175beb453.png" alt=""/></p>

<p>在小明的本地仓库中，他使用标准的 Git 过程开发功能：编辑、暂存（Stage）和提交。如果你不熟悉暂存区（Staging Area），这里说明一下：暂存区的用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。这样你可以创建一个高度聚焦的提交，尽管你本地修改很多内容。</p>

<pre class="line-numbers"><code class="language-text">git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3  </p>

<p>请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库上有了什么操作。对需要多个更简单更原子分块的大功能，这个做法是很有用的。</p>

<h3 id="toc_9"><a href="#%E5%B0%8F%E7%BA%A2%E5%BC%80%E5%8F%91%E5%8A%9F%E8%83%BD">#</a> 小红开发功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158394720-65e3103e-c24f-45ff-bb23-4d904b66ed0b.png" alt=""/></p>

<p>与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。和小明一样，她也不关心中央仓库有没有新提交；当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。</p>

<h3 id="toc_10"><a href="#%E5%B0%8F%E6%98%8E%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD">#</a> 小明发布功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158395108-56fdfe1d-1d9e-43b9-9813-b7cf7341e3f9.png" alt=""/></p>

<p>一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其它团队成员可以看到他的修改。他可以用下面的 <code>git push</code> 命令：</p>

<pre class="line-numbers"><code class="language-text">git push origin master 
</code></pre>

<p>1  </p>

<p>注意，origin 是在小明克隆仓库时 Git 创建的远程中央仓库别名。master 参数告诉 Git 推送的分支。由于中央仓库自从小明克隆以来还没有被更新过，所以 push 操作不会有冲突，成功完成。</p>

<h3 id="toc_11"><a href="#%E5%B0%8F%E7%BA%A2%E8%AF%95%E7%9D%80%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD">#</a> 小红试着发布功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158395475-680cea9d-ec8e-41fd-99fb-efd9ec8e6995.png" alt=""/></p>

<p>一起来看看在小明发布修改后，小红 push 修改会怎么样？她使用完全一样的 push 命令：</p>

<pre class="line-numbers"><code class="language-text">git push origin master 
</code></pre>

<p>1  </p>

<p>但她的本地历史已经和中央仓库有分岐了，Git 拒绝操作并给出下面很长的出错消息：</p>

<pre class="line-numbers"><code class="language-text">error: failed to push some refs to &#39;/path/to/repo.git&#39;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. &#39;git pull&#39;)
hint: before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5  </p>

<p>这避免了小红覆写正式的提交。她要先 pull 小明的更新到她的本地仓库合并上她的本地修改后，再重试。</p>

<h3 id="toc_12"><a href="#%E5%B0%8F%E7%BA%A2%E5%9C%A8%E5%B0%8F%E6%98%8E%E7%9A%84%E6%8F%90%E4%BA%A4%E4%B9%8B%E4%B8%8A-rebase">#</a> 小红在小明的提交之上 rebase</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158395958-1737b553-4754-4dae-8cd7-df544f522530.png" alt=""/></p>

<p>小红用 <code>git pull</code> 合并上游的修改到自己的仓库中。这条命令类似 <code>svn update</code> ——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：</p>

<pre class="line-numbers"><code class="language-text">git pull --rebase origin master 
</code></pre>

<p>1  </p>

<p><code>--rebase</code> 选项告诉 Git 把小红的提交移到同步了中央仓库修改后的 master 分支的顶部，如下图所示：</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158396431-9566d979-f983-4c9a-a300-3c09a0fbceab.png" alt=""/></p>

<p>如果你忘加了这个选项，pull 操作仍然可以完成，但每次 pull 操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。对于集中式工作流，最好是使用 rebase 而不是生成一个合并提交。</p>

<h3 id="toc_13"><a href="#%E5%B0%8F%E7%BA%A2%E8%A7%A3%E5%86%B3%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81">#</a> 小红解决合并冲突</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158396962-9887b337-c550-4409-a97a-a1d8d69b3fef.png" alt=""/></p>

<p>rebase 操作过程是把本地提交一次一个地迁移到更新了的中央仓库 master 分支之上。这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入 Bug 的分析，如果有必要，回滚修改也可以做到对项目影响最小。</p>

<p>如果小红和小明的功能是相关的，不大可能在 rebase 过程中有冲突。如果有，Git 在合并有冲突的提交处暂停 rebase 过程，输出下面的信息并带上相关的指令：</p>

<pre class="line-numbers"><code class="language-text">CONFLICT (content): Merge conflict in 
</code></pre>

<p>1  </p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158397434-dbf24e68-bf95-4661-94cb-cb6d2c392004.png" alt=""/></p>

<p>Git 很赞的一点是，任何人可以解决他自己的冲突。在这个例子中，小红可以简单的运行 <code>git status</code> 命令来查看哪里有问题。冲突文件列在 Unmerged paths（未合并路径）一节中：</p>

<pre class="line-numbers"><code class="language-text"># Unmerged paths:
# (use &quot;git reset HEAD &lt;some-file&gt;...&quot; to unstage)
# (use &quot;git add/rm &lt;some-file&gt;...&quot; as appropriate to mark resolution)
#
# both modified: &lt;some-file&gt; 
</code></pre>

<p>1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5  </p>

<p>接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让 <code>git rebase</code> 完成剩下的事：</p>

<pre class="line-numbers"><code class="language-text">git add
git rebase --continue 
</code></pre>

<p>1<br/><br/>
2  </p>

<p>要做的就这些了。Git 会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。</p>

<p>如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行 <code>git pull --rebase</code> 命令前的样子：</p>

<pre class="line-numbers"><code class="language-text">git rebase --abort 
</code></pre>

<p>1  </p>

<h3 id="toc_14"><a href="#%E5%B0%8F%E7%BA%A2%E6%88%90%E5%8A%9F%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD">#</a> 小红成功发布功能</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158398030-8155d112-e1ee-4281-b265-908ce7187dce.png" alt=""/></p>

<p>小红完成和中央仓库的同步后，就能成功发布她的修改了：</p>

<pre class="line-numbers"><code class="language-text">git push origin master 
</code></pre>

<p>1  </p>

<h2 id="toc_15"><a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h2>

<p>如你所见，仅使用几个 Git 命令我们就可以模拟出传统 Subversion 开发环境。对于要从 SVN 迁移过来的团队来说这太好了，但没有发挥出 Git 分布式本质的优势。</p>

<p>如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下功能分支工作流的收益。通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[#](#git-工作流简介) Git 工作流简介]]></title>
    <link href="http://565785929.github.io/16251579849229.html"/>
    <updated>2021-07-02T00:46:24+08:00</updated>
    <id>http://565785929.github.io/16251579849229.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0"></h1>

<h2 id="toc_1"><a href="#%E6%9C%AC%E8%8A%82%E8%A7%86%E9%A2%91">#</a> 本节视频</h2>

<ul>
<li>  <a href="https://www.bilibili.com/video/av32561679/">【视频】Git工作流指南-工作流简介</a></li>
</ul>

<h2 id="toc_2"><a href="#%E6%A6%82%E8%BF%B0">#</a> 概述</h2>

<p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。这篇指南通过总览公司团队中最常用的几种 Git 工作流让大家可以上手使用。</p>

<p>在阅读的过程中请记住，本文中的几种工作流是作为方案指导而不是条例规定。在展示了各种工作流可能的用法后，你可以从不同的工作流中挑选或揉合出一个满足你自己需求的工作流。</p>

<h3 id="toc_3"><a href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81">#</a> 集中式工作流</h3>

<p>如果你的开发团队成员已经很熟悉 Subversion，集中式工作流让你无需去适应一个全新流程就可以体验 Git 带来的收益。这个工作流也可以作为向更 Git 风格工作流迁移的友好过渡。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158291775-0d81e2a2-d80b-4eaf-86b2-7166979d9e2d.png" alt=""/></p>

<h3 id="toc_4"><a href="#%E5%8A%9F%E8%83%BD%E5%88%86%E6%94%AF%E5%B7%A5%E4%BD%9C%E6%B5%81">#</a> 功能分支工作流</h3>

<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用 <code>Pull Requests</code> 的方式讨论变更。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158292284-5f3d0648-f5f0-462c-bc1b-0c94970821ea.png" alt=""/></p>

<h3 id="toc_5"><a href="#gitflow-%E5%B7%A5%E4%BD%9C%E6%B5%81">#</a> GitFlow 工作流</h3>

<p>GitFlow 工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158292815-0b2eb829-6bcd-47c7-bd1c-cab3435c36f5.png" alt=""/></p>

<h3 id="toc_6"><a href="#forking-%E5%B7%A5%E4%BD%9C%E6%B5%81">#</a> Forking 工作流</h3>

<p>Forking 工作流是分布式工作流，充分利用了 Git 在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158293248-03fa5fe2-ccd0-4de5-bc99-89acce1fa96b.png" alt=""/></p>

<h3 id="toc_7"><a href="#pull-requests">#</a> Pull Requests</h3>

<p>Pull requests 让开发者更方便地进行协作的功能，提供了友好的 Web 界面可以在提议的修改合并到正式项目之前对修改进行讨论。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/738205/1625158293648-af4d3581-70d0-4aee-a1be-1f07a9f8ffda.png" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ray Tracing for one week]]></title>
    <link href="http://565785929.github.io/16197951416649.html"/>
    <updated>2021-04-30T23:05:41+08:00</updated>
    <id>http://565785929.github.io/16197951416649.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[科学上网]]></title>
    <link href="http://565785929.github.io/16137917098988.html"/>
    <updated>2021-02-20T11:28:29+08:00</updated>
    <id>http://565785929.github.io/16137917098988.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16137917098988/16193973348755.jpg" alt="" style="width:150px;"/></p>

<h2 id="toc_0">背景</h2>

<p>自从天朝有了言论管制，科学上网的话题就一直存在，于是大量的梯子软件应运而生。但是GFW与这些梯子软件的斗争从来都没有停止过，一直是此消彼长，墙越来越高，科学上网技术也是持续突破，不断涌现出新技术、新工具。现在最主流的科学上网技术有VPN/SS/SSR/V2Ray/Trojan/Trojan-Go，还有小众的 WireGuard、Brook、Snell 和 NaiveProxy 等，本篇文章不讨论Brook、NaiveProxy以及Snell协议。SS是科学上网代理协议的鼻祖，Snell和Brook是小众协议，Snell协议一直没有开源，是iOS平台非常知名的Surge软件团队开发的专属协议，Brook配套设施不完善；其中，VPN/SS/SSR最为出名，V2Ray和Trojan/Trojan-Go作为新星，正在受到越来越多的关注和使用。</p>

<h2 id="toc_1">什么是VPN和WireGuard，它们有什么关系？</h2>

<p>VPN是英文 Virtual Private Network 的缩写，中文名称为虚拟专用网络，是一种加密通信技术。VPN 只是一个统称，它有很多的具体实现，比如PPTP、L2TP、IPSec和OpenVPN等。VPN是在公用网络上建立专用网络，并对通信进行加密，防止传输数据被识别或篡改，以保障通信的安全。当你在VPN网络中通信，就相当于通过物理的内网专线进行通信。由此可见，VPN绝不是为了科学上网而生，而是更加注重数据信息的安全，很多大型企业和高校的远程SOHO办公使用VPN较多。</p>

<p>WireGuard 是最新开发的VPN协议，比主流的VPN技术有明显优势，被誉为下一代VPN。WireGuard有如下特点：</p>

<p>WireGuard 的优点：</p>

<ul>
<li>更轻便：以Linux内核模块的形式运行，资源占用小。</li>
<li>更高效：相比目前主流的IPSec、OpenVPN等VPN协议，WireGuard的效率要更高。</li>
<li>更快速：比目前主流的VPN协议，连接速度要更快。</li>
<li>更安全：使用了更先进的加密技术。</li>
<li>更易搭建：部署难度相对更低。</li>
<li>更隐蔽：以UDP协议进行数据传输，比TCP协议更低调。</li>
<li>不易被封锁：TCP阻断对WireGuard无效，IP被墙的情况下仍然可用。</li>
<li>更省电：不使用时不进行数据传输，移动端更省电。</li>
</ul>

<p>WireGuard 的不足：</p>

<ul>
<li>处于研发初期，各种功能及支持有待完善。</li>
<li>由于使用UDP协议，BBR、锐速等TCP网络加速工具，对WireGuard无效。</li>
<li>部分运营商可能会对UDP协议进行QOS限速，WireGuard会受到一定影响。</li>
<li>客户端分流功能较弱，对GFWList的支持不足。</li>
</ul>

<p>WireGuard虽然有一些不足，但WireGuard的优点更突出，而且可以拯救被封IP的VPS，所以 WireGuard 是 SS/SSR/V2Ray/Trojan 等代理工具之外的一个不错的选择。</p>

<h2 id="toc_2">什么是 Shadowsocks？</h2>

<p>SS 是 Shadowsocks 的缩写，中文名为影梭，为了避免关键词过滤，网友喜欢将 Shadowsocks 称为“酸酸”，是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。Shadowsocks 由 Clowwindy 为了自己使用谷歌查资料而编写，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。后来，他觉得这个东西非常好用、速度也很快，于是他在 GitHub 上共享了源码。在天朝，本工具被广泛用于突破GFW，以浏览被封锁、遮蔽或干扰的内容，由于 Shadowsocks 被广泛传播，导致作者被请去喝茶。2015年8月22日，Shadowsocks 原作者 Clowwindy 称迫于天朝内部的压力，宣布停止维护此计划（项目），并移除其个人页面所存储的源代码，而且保证永不再参与维护更新。值得庆幸地是，Shadowsocks 仍然有不少国外社区成员在维护更新。后来贡献者Librehat也为Shadowsocks补上了一些数据混淆类特性，甚至增加了类似Tor的可插拔传输层功能。</p>

<h2 id="toc_3">什么是 ShadowsocksR</h2>

<p>SSR 是 ShadowsocksR 的缩写，网民爱称“酸酸乳”，是在 Shadowsocks 的作者被请去喝茶之后，网名为breakwa11的用户发起的Shadowsocks的一个分支版本，它在Shadowsocks的基础上增加了一些数据混淆方式，修复了部分安全问题并提高QoS优先级。由于 ShadowsocksR 在协议和混淆方面做了改进，更加不容易被GFW检测到，而且兼容原 Shadowsocks，并为新项目取名叫 Shadowsocks-R，一开始部分代码由社区人员进行更新。由于不完全开源，也导致后来使用 SS 和 SSR 的用户分成两个阵营，互相撕逼，直到开发者 Breakwa11(破娃) 被人肉出来。Breakwa11(破娃)最终决定删除 Shadowsocks-R 项目的所有代码，并解散了所有相关群组。</p>

<p>事件始末澄清：ShadowsocksR 的作者一开始曾有过违反GPL，在发布二进制文件时不开放源码的争议。不过后来 Shadowsocks-R 项目由 breakwa11 采用了与 Shadowsocks 相同的GPL、Apache许可证、MIT许可证等多重自由软件许可协议。</p>

<p>2017年7月19日，ShadowsocksR 作者 breakwa11 在Telegram频道 ShadowsocksR news 里转发了深圳市启用SS协议检测的消息并被大量用户转发，在TG圈引发恐慌。7月24日，breakwa11 发布了闭源的SS被动检测程序，引发争议。7月27日，breakwa11 遭到自称 “ESU.TV” 的不明身份人士人身攻击，对方宣称如果不停止开发并阻止用户讨论此事件将发布更多包含个人隐私的资料，随后 breakwa11 表示遭到对方人肉搜索并公开个人资料的是无关人士。为了防止对方继续伤害无关人士，breakwa11 将删除GitHub上的所有代码、解散相关交流群组，并停止 ShadowsocksR 项目。</p>

<p>从本质上说，Shadowsocks 和 ShadowsocksR 的基本原理相同，都是基于 socks5 的代理工具，只在本地客户端和服务器端对数据包加解密，然后使用 socks5 协议转发加密的数据包，而不用在乎使用什么协议，所以 Socks5 代理比其他应用层代理速度要快得多。</p>

<h2 id="toc_4">【科普】什么是 socks5 代理？</h2>

<p>socks5 代理的原理是把你的网络数据请求先发送到你的代理服务器，然后由代理服务器转发给目标；如果目标有反馈发送到代理服务器，那么代理服务器会将数据包直接传回你的本地网络，整个过程只是数据的二次传输，并没有做额外的处理。比如，现在你在深圳，你的代理服务器在日本，如果你想要访问Google，那么你首先要把数据请求通过本地 socks5 代理客户端发给你在香港的服务器上的 socks5 代理服务端，然后你在香港的服务器将数据请求发送给Google，再把Google反馈的结果传回你的本地电脑的 socks5 客户端，这样就可以绕开GFW的检测而实现科学上网。</p>

<p>显而易见，socks5代理的所有数据走的仍然是公网，而且在公网传输过程中，没有对数据进行任何加密和混淆，这跟VPN在公网建立虚拟专用通道传输过程中，对数据高强度加密的方式完全不同。Shadowsocks 和 ShadowsocksR 只在客户端和服务器端对数据做了简单加密和认证，主要功能是流量转发，过墙才是主要目的。虽然现在 ShadowsocksR 已经停止更新很久了，而 Shadowsocks 仍处于社区人员的更新维护之中，不断修复漏洞并增加新功能，所以现在 Shadowsocks 比 ShadowsocksR 更强大。</p>

<p><strong>我在此提醒大家</strong>：请不要迷信 SSR 一定比 SS 强，也包括现在的V2Ray、Trojan，甚至WireGuard等，因为增加混淆意味着损失速度，混淆加密越是强悍，那么其速度和稳定性损失就越大，另外 SSR 至今已经被研究透了，而且长期没有更新维护，其流量特征是可以被GFW精准识别的，所以用 SSR 跟用 SS 没有本质区别，由于SS一直在更新维护，反而更稳定。我们要做的就是爱国爱家爱生活，勿谈国是，专心做好自己的事情就是了。天朝一直都清楚，跨境相关业务一直存在，尤其是近些年跨境电商的蓬勃发展，很多做跨境相关业务的朋友不外出通讯是不可能的一件事情，但所谓的公司备案VPN却非常昂贵，一般用户根本承担不起费用。但我们一定要“做好分内事，勿论他人非”，尤其不发表涉及天朝的言论和行为，做一个天朝的好公民、中华的好儿女，这样天朝是没有必要跟她的好儿女过不去的。</p>

<h2 id="toc_5">什么是 V2Ray？</h2>

<p>V2Ray 是在Shadowsocks 被封杀之后，为了表示抗议而开发的，属于后起之秀，功能更加强大，为抗GFW封锁而生。V2Ray 现在已经是 Project V 项目的核心工具，而 Project V 是一个平台，其中也包括支持 Shadowsocks 协议。由于 V2Ray 早于 Project V 项目，而且名声更大，所以我们习惯称 Project V 项目为 V2Ray，所以我们平时所说的 V2Ray 其实就是 Project V  这个平台，也就是一个工具集。其中，只有 VMess协议是V2Ray社区原创的专属加密通讯协议，被广泛应用于梯子软件。</p>

<p>V2Ray目前支持以下协议（截止到2019年12月）：</p>

<ul>
<li>Blackhole：中文名称“黑洞”，是一个出站数据协议，它会阻碍所有数据的出站，配合路由（Routing）一起使用，可以达到禁止访问某些网站的效果。</li>
<li>Dokodemo-door：中文名称“任意门”，是一个入站数据协议，它可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。</li>
<li>Freedom：是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。</li>
<li>HTTP：超文本传输协议，是传统的代理协议</li>
<li>MTProto：Telegram 的开发团队开发的专用协议，是一个 Telegram 专用的代理协议。在 V2Ray 中可使用一组入站出站代理来完成 Telegram 数据的代理任务。目前只支持转发到 Telegram 的 IPv4 地址。</li>
<li>Shadowsocks：最早被个人开发的科学上网梯子协议，但 V2Ray 目前不支持 ShadowsocksR。</li>
<li>Socks：标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5，也是传统的代理协议。</li>
<li>VMess：是V2Ray 专用的加密传输协议，它分为入站和出站两部分，通常作为 V2Ray 客户端和服务器之间的桥梁。因为增加了混淆和加密，据说比 Shadowsocks 更安全。现在的机场支持 V2Ray，一般是指支持 VMess 协议。VMess 依赖于系统时间，请确保使用 V2Ray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。</li>
</ul>

<p>截止到2019年12月，V2Ray 可选的传输层配置有：TCP、mKCP、WebSocket、HTTP/2、DomainSocket、QUIC。其中，mKCP、QUIC和TCP用于优化网络质量；WebSocket用于伪装；HTTP/2和DomainSocket用于传输以及TLS加密。</p>

<p>V2Ray不仅可以在传输层配置 TLS 使 HTTP 和 SOCKS 变成 HTTPS 和 SOCKS over TLS 协议，也可以使MTProto、Shadowsocks 和 VMess 通过传输层配置TLS加密伪装成 TLS 流量。所以，VMess 配置 TLS 加密是最常见的做法，但没人会对 Shadowsocks 使用 TLS 加密，因为这完全没意义。</p>

<h2 id="toc_6">什么是 Trojan/Trojan-Go？</h2>

<p>Trojan，原来多是指特洛伊木马，是一种计算机病毒程序。但是，我们今天所说的Trojan是一种新的科学上网技术，全称为Trojan-GFW，是目前最成功的科学上网伪装技术之一。你可以认为Trojan是V2Ray的“WS+TLS”模式的精简版，速度比V2Ray更快，伪装比V2Ray更逼真，更难以被GFW识别。</p>

<p>Trojan工作原理：Trojan通过监听443端口，模仿互联网上最常见的 HTTPS 协议，把合法的Trojan代理数据伪装成正常的 HTTPS 通信，并真正地完整完成的TLS 握手，以诱骗GFW认为它就是 HTTPS，从而不被识别。Trojan处理来自外界的 HTTPS 请求，如果是合法的，那么为该请求提供服务，否则将该流量转交给Caddy、Nginx等 web 服务器，由 Caddy、Nginx 等为其提供网页访问服务。基于整个交互过程，这样能让你的VPS更像一个正常的web服务器，因为Trojan的所有行为均与 Caddy、Nginx等 web 服务器一致，并没有引入额外特征，从而达到难以识别的效果。</p>

<p>Trojan-Go是Trojan-GFW的分支项目，对Trojan进行性能优化，并增加不少新功能，Trojan-Go性能和功能均有大幅度的提升，而且支持分流和CDN。</p>

<h2 id="toc_7">什么是Xray？</h2>

<p>Xray与V2Ray完全类同，Xray 是 Project X 项目的核心模块。因为Xray和XTLS黑科技的作者rprx曾经是V2fly社区的重要成员，所以Xray直接Fork全部V2Ray的功能，然后进行性能优化，并增加了新功能，使Xray在功能上成为了V2Ray的超集，且完全兼容V2Ray。</p>

<p>简而言之，Xray是V2Ray的项目分支，Xray是V2Ray的超集，就跟Trojan-Go和Trojan-GFW的关系类似，而且Xray性能更好、速度更快，更新迭代也更频繁。由于自V2ray-core 4.33.0 版本起，删除了XTLS黑科技，但仍然支持VLESS，所以是否原生支持XTLS是Xray和V2Ray最大的区别之一。</p>

<h2 id="toc_8">VPN、SS/SSR、V2Ray/Xray 和 Trojan/Trojan-Go 之间有什么区别及优缺点</h2>

<h3 id="toc_9">（1）原理不同</h3>

<p>VPN强调对公网传输过程中数据的加解密，SS/SSR/V2Ray/Xray/Trojan都是专注于在客户端和服务器端加解密，公网传输数据过程中特征没有VPN明显。</p>

<h3 id="toc_10">（2）目的不同</h3>

<p>VPN是走在公网中自建的虚拟专用通道，使用强大的加解密算法，为数据传输安全性、私密性而生，被广泛应用于企业、高校、科研部门等远程数据传输的领域；SS/SSR/V2Ray/Xray/Trojan/Trojan-Go是为了数据能够安全通过GFW而生，更强调的是对数据的混淆和伪装，加解密只是为了更好的隐藏数据特征而顺利绕过GFW的检测，数据内容加密可以有效绕过关键词的检测。</p>

<p>在天朝，如果你想用VPN翻墙几乎是不可能的，在平时不怎么限制还好，特殊时期VPN是断流最惨的。如果要需要匿名安全上网，VPN+TOR或SS/SSR+TOR也是不错的选择。当然，现在已经有了新的对抗技术，比如V2Ray/Xray、Trojan/Trojan-Go、WireGuard等。另外，有一些比较著名的工具，如红杏出墙、蓝灯（Lantern）、Tor Browser、赛风3（Psiphon3）等，都相继被墙，现在已经很少人使用了。</p>

<h2 id="toc_11">项目诞生的大致时间顺序</h2>

<p>VPN &gt; SS &gt; SSR/V2Ray/WireGuard &gt; Trojan/Trojan-Go &gt; Xray</p>

<h2 id="toc_12">对梯子软件/科学上网工具的总结</h2>

<p>VPN虽然天生不是为了做梯子，但却是最出名的梯子软件、众人皆知的科学上网工具，但是由于VPN特征太明显，现在非大陆正规公司的VPN基本被禁的差不多了；SS/SSR为科学上网而生，但是加密和混淆较弱，而且已经被GFW精准识别，在科学上网方面的前景堪忧，但是仍然适用于专线，网络速度比V2Ray/Trojan/Trojan-Go更快；V2Ray/Xray为科学上网而生，天生不凡，已经成长为一个平台框架，拥有自研协议VMess和VLESS，功能非常强大；WireGuard被誉为新一代VPN，技术强大，而且已经被写入Linux内核，前景光明，但是在科学上网方面并不够隐蔽，所以不是未来主流的科学上网工具；Trojan/Trojan-Go为科学上网而生，天生只为了模仿互联网最流行的HTTPS协议而存在，是目前最成功的伪装工具之一，功能与V2Ray的“Vmess+WS+TLS”模式相当，但是更轻量，伪装更逼真，目前GFW几乎无法识别其特征，而且目前Trojan-Go在性能和速度方面的表现均优于V2Ray的VMess和VLESS协议。所以，我认为Trojan/Trojan-Go会跟V2Ray一样成为将来科学上网的主流工具之一，SSR由于长期得不到维护而逐渐退出历史舞台，Shadowsocks/SS依然是最轻量的科学上网代理协议，没有之一。</p>

<p><a href="https://iyideng.me/black-technology/cgfw/vpn-ss-ssr-v2ray-trojan-wireguard-bypass-gfw.html">来源</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动登录工具开发]]></title>
    <link href="http://565785929.github.io/16110385786886.html"/>
    <updated>2021-01-19T14:42:58+08:00</updated>
    <id>http://565785929.github.io/16110385786886.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">涉及工具技术</h2>

<ul>
<li>Tampermonkey</li>
<li>jQuery</li>
<li>Tesseract-OCR</li>
<li>Flask</li>
<li><a href="https://pillow.readthedocs.io/en/stable/">Pillow</a></li>
</ul>

<h2 id="toc_1">前言</h2>

<p>开发软件系统时必然会有用户登陆的模块。每次验证自己的功能时，总是绕不开输入账号密码，这已经是很麻烦的了，还得输入不好辨认的验证码。</p>

<p>为了简化登陆步骤，我通过使用图像识别 OCR 技术，和Web应用框架Flask搭建一个验证码自动识别的服务。并结合强大的浏览器插件Tampermonkey，编写一个简单的油猴脚本，在不入侵源系统的基础上，实现不输入验证码登陆。也为后期自动化测试奠定可操作的基础。</p>

<h2 id="toc_2">依赖安装</h2>

<p>示例环境Centos8</p>

<pre class="line-numbers"><code class="language-bash">sudo yum install epel-release
sudo yum install tesseract-devel leptonica-devel
 
yum install -y libjpeg-devel  libpng-devel
yum install -y autoconf automake libtool

yum install -y git wget
yum install -y gcc gcc-c++
yum install -y tesseract  tesseract-devel  
yum install -y python36
</code></pre>

<p>创建python虚拟环境</p>

<pre class="line-numbers"><code class="language-bash">python3.6 -m venv py36env
source py36env/bin/activate
</code></pre>

<p>python依赖安装</p>

<pre class="line-numbers"><code class="language-bash">pip install flask
pip install flask_cors
pip install tesserocr
pip install pillow
pip install uwsgi
</code></pre>

<h2 id="toc_3">安装常见错误</h2>

<p><strong>找不到tesseract包</strong></p>

<blockquote>
<p>yum list tesseract <br/>
无数据 </p>
</blockquote>

<p><strong>解决</strong></p>

<pre class="line-numbers"><code class="language-text">yum -y install yum-utils
yum-config-manager --add-repo https://download.opensuse.org/repositories/home:/Alexander_Pozdnyakov/CentOS_8/
</code></pre>

<p><strong>TESSDATA_PREFIX问题</strong></p>

<blockquote>
<p>[Sajor@10-7-151-243 AutoLogin]$ tesseract captcha_denoising.png result <br/>
Error opening data file /usr/share/tesseract/4/tessdata/eng.traineddata<br/>
Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory.<br/>
Failed loading language &#39;eng&#39;<br/>
Tesseract couldn&#39;t load any languages!<br/>
Could not initialize tesseract.</p>
</blockquote>

<p><strong>解决</strong></p>

<p>搜索tessdata文件夹 </p>

<pre class="line-numbers"><code class="language-text">find / -type d -iname &quot;tessdata&quot;
</code></pre>

<p>发现确实没有 <code>eng.traineddata</code> 文件，则下载一个。</p>

<pre class="line-numbers"><code class="language-text">wget https://github.com/tesseract-ocr/tessdata/raw/master/eng.traineddata

sudo mv -v eng.traineddata /usr/local/share/tessdata/
</code></pre>

<h2 id="toc_4">验证码识别</h2>

<p>我们开发的系统登陆页面是这样的</p>

<p><img src="media/16110385786886/16110394454445.jpg" alt="" style="width:814px;"/></p>

<p>其中验证码图片<br/>
<img src="media/16110385786886/captcha3.png" alt="captcha3"/></p>

<p>先分析此验证码图片有以下特点</p>

<ul>
<li>颜色多样</li>
<li>字母较大，干扰线细</li>
<li>线条笔直无扭曲</li>
</ul>

<p>我们可以这样处理</p>

<h3 id="toc_5">颜色多样</h3>

<p>针对颜色多样，我们可以先给图片做灰度处理再做二值化处理，这是识别前处理验证码的基操。</p>

<blockquote>
<p><strong>灰度图像</strong>: 每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。<br/>
<strong>转换公式</strong>: <code>L = R * 299/1000 + G * 587/1000+ B * 114/1000</code></p>
</blockquote>

<pre class="line-numbers"><code class="language-text">from PIL import Image
image = Image.open(file).convert(&#39;L&#39;)
</code></pre>

<p><img src="media/16110385786886/16110398931116.jpg" alt="" style="width:323px;"/></p>

<p>之后对灰度图片做二值化，使图片非黑即白，可以通过调整下图中<code>threshold</code>的值来过滤少部分颜色浅的干扰线，因为图片中字母部分也可能出现亮黄色的情况，为了防止误删要识别的文字，我将阈值先调高一些，少过滤一些颜色。</p>

<blockquote>
<p><strong>二值图像</strong>: 非黑即白。每个像素用8个bit表示，0表示黑，255表示白。</p>

<pre class="line-numbers"><code class="language-text">image.convert(&#39;1&#39;)
</code></pre>
</blockquote>

<p><img src="media/16110385786886/16110403706745.jpg" alt="" style="width:523px;"/></p>

<h3 id="toc_6">字母较大，干扰线细</h3>

<p>因为字母较大，像素较多，而干扰线的较细，我们可以使用这个策略来去除干扰线。</p>

<pre class="line-numbers"><code class="language-text">遍历图片中每一个像素点：
    如果这个像素点为黑色：
        观察它四面八方的像素点颜色，如果少于四个点为黑色：
            将这个点变为白色
</code></pre>

<p>这个策略的大致意思就是将图像中置于边缘的像素删除掉。因为字母较大，像素比较多，删除一圈也不会有什么影响。</p>

<p><img src="media/16110385786886/16110409153447.jpg" alt="" style="width:310px;"/></p>

<h3 id="toc_7">线条笔直无扭曲</h3>

<p>通过上一步的降噪处理得到的结果已经很好了，因为线条笔直没有扭曲，可以直接丢给OCR来识别了！</p>

<p>网络中现成的OCR识别工具有很多，比如百度OCR，Tesseract-OCR。</p>

<p>第三方的OCR得经过注册，使用他们提供的token调用接口，我就直接使用Python的第三方库Tesseract来搞。</p>

<p>安装必要的包之后直接调用即可。</p>

<pre class="line-numbers"><code class="language-text">import tesserocr
result = tesserocr.image_to_text(image)
</code></pre>

<p><img src="media/16110385786886/16110413762073.jpg" alt="" style="width:360px;"/></p>

<h2 id="toc_8">编写Web接口</h2>

<p>使用Jupyter notebook 验证好功能后，将代码封装成类，方便调用。</p>

<p>之后使用Flask的 helloworld 工程简单修改一下，实现一个可调用的接口。</p>

<p>简单实用<code>uwsgi</code>部署一下这个web项目，配置<code>uwsgi.ini</code>文件将下文中<code>/root/AutoLogin</code>路径改为自己的目录。</p>

<pre class="line-numbers"><code class="language-text">[uwsgi]
master = true
http=:5000
chdir = /root/AutoLogin
wsgi-file=/root/AutoLogin/app.py
callable=app
processes=4
threads=2
buffer-size = 65536
vacuum=true
pidfile =/root/AutoLogin/uwsgi.pid
</code></pre>

<p>启动命令：<br/>
<code>uwsgi --ini uwsgi.ini</code><br/>
重启命令：<br/>
<code>uwsgi --reload uwsgi.pid</code><br/>
关闭命令：<br/>
<code>uwsgi --stop uwsgi.pid</code></p>

<h2 id="toc_9">NginX代理</h2>

<p>新建一个配置文件</p>

<pre class="line-numbers"><code class="language-text">vi /etc/nginx/conf.d/autologin.conf
</code></pre>

<p>输入以下内容</p>

<pre class="line-numbers"><code class="language-text">        server{

                listen       80;
                listen       [::]:80;
                server_name  autoLogin.sajor.top;
                access_log  /var/log/nginx/access.log;
                error_log   /var/log/nginx/error.log;

                location /{
                        proxy_pass http://localhost:5000;
                }
        }
</code></pre>

<p>检查并重启</p>

<pre class="line-numbers"><code class="language-text">nginx -t
service nginx restart
</code></pre>

<p>查看 mem top 10</p>

<pre class="line-numbers"><code class="language-text">ps aux | grep -v PID | sort -rn -k 4| head
</code></pre>

<h2 id="toc_10">--</h2>

<p>-- 未完待续。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql5.7 无法设置0000-00-00默认日期]]></title>
    <link href="http://565785929.github.io/16022150270617.html"/>
    <updated>2020-10-09T11:43:47+08:00</updated>
    <id>http://565785929.github.io/16022150270617.html</id>
    <content type="html"><![CDATA[
<p>问题：<br/>
<img src="media/16022150270617/16125316270697.jpg" alt=""/></p>

<p><img src="media/16022150270617/16125316380058.jpg" alt=""/></p>

<p>使用命令行。navicat不好使</p>

<h2 id="toc_0">解决方案：</h2>

<p>使用root登陆数据库</p>

<ol>
<li>查看sql_mode：
<code>select @@sql_mode;</code></li>
</ol>

<p>获得结果：<br/>
<code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>

<ol>
<li>NO_ZERO_IN_DATE,NO_ZERO_DATE是无法默认为‘0000-00-00 00:00:00’的根源，去掉之后再次新建表就可以了</li>
</ol>

<p><code>SET GLOBAL sql_mode=&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</code></p>

<h2 id="toc_1">注：</h2>

<p>NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零<br/>
NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p>

<p>测试新建表，ok。可以了。</p>

<h2 id="toc_2">终极解决方案</h2>

<p>修改my.ini配置文件直接修改启动sql_mode<br/>
在[mysqld]下添加<br/>
可以设置<code>sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>

<p>或者为了避免group by限制 直接设置为<code>STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION</code></p>

<pre class="line-numbers"><code class="language-text">[mysqld]
sql_mode=STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION
</code></pre>

<p>dos命令重启mysql</p>

<pre class="line-numbers"><code class="language-dos">net stop mysql
net start mysql
</code></pre>

<p><img src="media/16022150270617/16125316826946.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yum安装提示错误Thread/process failed: Thread died in Berkeley DB librar]]></title>
    <link href="http://565785929.github.io/15914577057463.html"/>
    <updated>2020-06-06T23:35:05+08:00</updated>
    <id>http://565785929.github.io/15914577057463.html</id>
    <content type="html"><![CDATA[
<p>问题描述：#<br/>
yum 安装更新提示 rpmdb: Thread/process failed: Thread died in Berkeley DB library</p>

<p>问题解决：#<br/>
01、删除yum临时库文件</p>

<p><code>rm -fr /var/lib/rpm/__db.*</code></p>

<p>02、重建rpm数据库</p>

<p><code>rpm --rebuilddb</code></p>

<p>03、清理缓存及生产yumdb缓存</p>

<p><code>yum clean all</code><br/>
<code>yum makecache</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[离线支付方案]]></title>
    <link href="http://565785929.github.io/15873033963371.html"/>
    <updated>2020-04-19T21:36:36+08:00</updated>
    <id>http://565785929.github.io/15873033963371.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">二维码登陆+2FA双因素认证</h1>

<p>二者都是很常用的技术，但是两者相结合遍可以用于二维码离线支付。</p>

<h2 id="toc_1">密码安全</h2>

<p>首先讨论一下如何让密码安全？<br/>
注册时密码数据流，密码首先在web或客户端由用户手动输入，然后经过网络传输至服务端，服务端入库。<br/>
登陆时密码数据流，密码也是在web或客户端由用户手动输入，然后经过网络传输至服务端，服务端查库。</p>

<p>所以我们可以在客户端、网络传输、数据库中分别采用下图方案保护我们的密码。</p>

<p><img src="media/15868546287595/15868573710308.jpg" alt="" style="width:1403px;"/></p>

<h2 id="toc_2">二维码登陆原理</h2>

<p>登录做两件事<br/>
1、告诉系统我是谁;<br/>
2、向系统证明我是谁;</p>

<p>二维码其实是字符串的图片表现形式</p>

<p><strong>基于token的认证机制</strong><br/>
1、首次登录客户端向服务器传送密码+设备信息进行认证;<br/>
2、服务端认证通过后,生成token与设备信息进行对应,并存储在服务端并将token回传到客户端;<br/>
3、客户端每次访问API时,需要携带token+设备信息作为验证信息;<br/>
4、服务端验证token+设备信息是否对应,验证通过后,返回API响应,验证不通过,拒绝服务;<br/>
特别注意:token是某个客户端私有的,即使有token,没有对应的设备信息,也是验证不通过的</p>

<h2 id="toc_3">双因素认证（2FA）</h2>

<p>一般情况下，网站登录都使用账号密码的方式登录，这是最常见的认证方法，但是不安全，容易泄露和冒充。</p>

<h3 id="toc_4">双因素认证概念：</h3>

<p>一般来说，三种不同类型的证据，可以证明一个人的身份。</p>

<ul>
<li>秘密信息：只有该用户知道、其他人不知道的某种信息，比如密码</li>
<li>个人物品：该用户的私人物品，比如身份证、钥匙、手机号</li>
<li>生物特征：该用户的遗传特征，比如指纹、相貌、虹膜等</li>
</ul>

<p>这些证据就称为三种”因素“。因素越多，证明力就越强，身份就越可靠。</p>

<p>双因素认证就是指，通过认证同事需要两个因素的证据。</p>

<p>银行卡取钱就是最常见的双因素认证。用户必须同时提供银行卡和密码，才能取到现金。</p>

<h3 id="toc_5">双因素认证方案</h3>

<p>常用的双因素组合是密码 + 某种个人物品，比如网上银行的 U 盾。用户插上 U 盾，再输入密码，才能登录网上银行。</p>

<p>但是，用户不可能随时携带 U 盾，手机才是最好的替代品。密码 + 手机就成了最佳的双因素认证方案。</p>

<p>国内的很多网站要求，用户输入密码时，还要提供短消息发送的验证码，以证明用户确实拥有该手机。</p>

<p>但是，短消息是不安全的，容易被拦截和伪造，SIM 卡也可以克隆。已经有案例，先伪造身份证，再申请一模一样的手机号码，把钱转走。</p>

<p>因此，安全的双因素认证不是密码 + 短消息，而是下面要介绍的 TOTP。</p>

<h3 id="toc_6">TOTP的概念</h3>

<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href="https://tools.ietf.org/html/rfc6238">RFC6238</a>。</p>

<p>它的步骤如下。</p>

<p>第一步，用户开启双因素认证后，服务器生成一个密钥。</p>

<p>第二步：服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥。<br/>
<img src="media/15847222662823/15847227437312.jpg" alt=""/><br/>
注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥。</p>

<p>第三步，用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器。<br/>
<img src="media/15847222662823/15847227654261.jpg" alt=""/><br/>
第四步，服务器也使用密钥和当前时间戳，生成一个哈希，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</p>

<h3 id="toc_7">TOTP算法</h3>

<p>仔细看上面的步骤，你可能会有一个问题：手机客户端和服务器，如何保证30秒期间都得到同一个哈希呢？</p>

<p>答案就是下面的公式。</p>

<p>TC = floor((unixtime(now) − unixtime(T0)) / TS)</p>

<p>上面的公式中，TC 表示一个时间计数器，unixtime(now)是当前 Unix 时间戳，unixtime(T0)是约定的起始时间点的时间戳，默认是0，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>

<p>TC = floor(unixtime(now) / 30)<br/>
所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。</p>

<p>接下来，就可以算出哈希了。</p>

<p>TOTP = HASH(SecretKey, TC)<br/>
上面代码中，HASH就是约定的哈希函数，默认是 SHA-1。</p>

<p>TOTP 有硬件生成器和软件生成器之分，都是采用上面的算法。</p>

<h3 id="toc_8">总结</h3>

<p>双因素认证的优点在于，比单纯的密码登录安全得多。就算密码泄露，只要手机还在，账户就是安全的。各种密码破解方法，都对双因素认证无效。</p>

<p>缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。</p>

<p>双因素认证还有一个最大的问题，那就是帐户的恢复。</p>

<p>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。</p>

<h2 id="toc_9">二维码在线支付</h2>

<p>首先谈一下在线支付方案。<br/>
首先这个二维码其实只是用户的唯一标识。让商户端扫描之后，知道是谁要付款。</p>

<p>所以简单实现，一般为客户端请求服务端，服务端在redis中存储客户信息，一分钟失效。<br/>
然后商户端扫描redis中存储的这个uuid，通过这个uuid获取到客户的信息后，开始下订单，扣款。</p>

<p><img src="media/15873033963371/15873054303125.jpg" alt="" style="width:576px;"/></p>

<h2 id="toc_10">二维码离线支付</h2>

<p>上文的方法有个弊端就是，如果客户端没有网络，就无法请求服务端生成二维码并支付了。这严重影响了用户的体验。</p>

<p>如果客户端可以自己生成uuid就好了。</p>

<ol>
<li>服务器生成token，通过加密方式（如https）传递到客户端。</li>
<li>打开付款码时，本地生成一段含有token和当前时间时间戳的哈希值，如sha1(token+UnixTimestamp),转换为byte[]并截取指定长度后转换为int变量otp。</li>
<li>设置支付用户账号（手机号）为int变量id。</li>
<li>设otp在[0, n]中，通过code=id*n+otp，即可将OTP和ID合并在同一个数字里，成为最终的二维码，并每隔指定时间更新一次。</li>
<li>通过商家扫码枪扫描，服务器获取了code，通过(int)(code/n)得到id，通过code%n得到otp。</li>
<li>通过id找到token，通过token和当前时间验证otp。</li>
<li>验证通过即可下单。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[双因素认证（2FA）]]></title>
    <link href="http://565785929.github.io/15847222662823.html"/>
    <updated>2020-03-21T00:37:46+08:00</updated>
    <id>http://565785929.github.io/15847222662823.html</id>
    <content type="html"><![CDATA[
<p>一般情况下，网站登录都使用账号密码的方式登录，这是最常见的认证方法，但是不安全，容易泄露和冒充。</p>

<h2 id="toc_0">双因素认证概念：</h2>

<p>一般来说，三种不同类型的证据，可以证明一个人的身份。</p>

<ul>
<li>秘密信息：只有该用户知道、其他人不知道的某种信息，比如密码</li>
<li>个人物品：该用户的私人物品，比如身份证、钥匙、手机号</li>
<li>生物特征：该用户的遗传特征，比如指纹、相貌、虹膜等</li>
</ul>

<p>这些证据就称为三种”因素“。因素越多，证明力就越强，身份就越可靠。</p>

<p>双因素认证就是指，通过认证同事需要两个因素的证据。</p>

<p>银行卡取钱就是最常见的双因素认证。用户必须同时提供银行卡和密码，才能取到现金。</p>

<h2 id="toc_1">双因素认证方案</h2>

<p>常用的双因素组合是密码 + 某种个人物品，比如网上银行的 U 盾。用户插上 U 盾，再输入密码，才能登录网上银行。</p>

<p>但是，用户不可能随时携带 U 盾，手机才是最好的替代品。密码 + 手机就成了最佳的双因素认证方案。</p>

<p>国内的很多网站要求，用户输入密码时，还要提供短消息发送的验证码，以证明用户确实拥有该手机。</p>

<p>但是，短消息是不安全的，容易被拦截和伪造，SIM 卡也可以克隆。已经有案例，先伪造身份证，再申请一模一样的手机号码，把钱转走。</p>

<p>因此，安全的双因素认证不是密码 + 短消息，而是下面要介绍的 TOTP。</p>

<h2 id="toc_2">TOTP的概念</h2>

<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href="https://tools.ietf.org/html/rfc6238">RFC6238</a>。</p>

<p>它的步骤如下。</p>

<p>第一步，用户开启双因素认证后，服务器生成一个密钥。</p>

<p>第二步：服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥。<br/>
<img src="media/15847222662823/15847227437312.jpg" alt=""/><br/>
注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥。</p>

<p>第三步，用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器。<br/>
<img src="media/15847222662823/15847227654261.jpg" alt=""/><br/>
第四步，服务器也使用密钥和当前时间戳，生成一个哈希，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</p>

<h2 id="toc_3">TOTP算法</h2>

<p>仔细看上面的步骤，你可能会有一个问题：手机客户端和服务器，如何保证30秒期间都得到同一个哈希呢？</p>

<p>答案就是下面的公式。</p>

<p>TC = floor((unixtime(now) − unixtime(T0)) / TS)</p>

<p>上面的公式中，TC 表示一个时间计数器，unixtime(now)是当前 Unix 时间戳，unixtime(T0)是约定的起始时间点的时间戳，默认是0，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>

<p>TC = floor(unixtime(now) / 30)<br/>
所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。</p>

<p>接下来，就可以算出哈希了。</p>

<p>TOTP = HASH(SecretKey, TC)<br/>
上面代码中，HASH就是约定的哈希函数，默认是 SHA-1。</p>

<p>TOTP 有硬件生成器和软件生成器之分，都是采用上面的算法。</p>

<h2 id="toc_4">总结</h2>

<p>双因素认证的优点在于，比单纯的密码登录安全得多。就算密码泄露，只要手机还在，账户就是安全的。各种密码破解方法，都对双因素认证无效。</p>

<p>缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。</p>

<p>双因素认证还有一个最大的问题，那就是帐户的恢复。</p>

<p>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux]]></title>
    <link href="http://565785929.github.io/15833368444152.html"/>
    <updated>2020-03-04T23:47:24+08:00</updated>
    <id>http://565785929.github.io/15833368444152.html</id>
    <content type="html"><![CDATA[
<p>Linux下的程序往往使你更加有效率，因为他们可以更高效的使用电脑的资源</p>

<p><strong>不同的Linux发行版之间的主要区别：</strong></p>

<p>1、安装方法不一样，有的复杂，有的简单。</p>

<p>2、安装应用程序的方式不一样。</p>

<p>3、预装的应用程序不一样。</p>

<h3 id="toc_0">linux发行版</h3>

<p>1、RedHat：性能稳定，老牌的linux发行版。收费的是RedHat Enterprise Linux（RHEL。redhat企业版）。目前RedHat分为两个系列：由RedHat公司提供收费技术支持。以及社区开发的免费的Fedora。</p>

<p>2、Fedora：RedHat的社区免费后继版，非常强大。</p>

<p>3、CentOS：国内许多企业选择CentOS，CentOS可以算是RHEL的克隆版，最大的好处就是免费。</p>

<p>4、SUSE：德国最著名的Linux发行版。</p>

<p>5、Debian：算是迄今为止，最遵循GNU规范的linux系统。（gnu的目标就是创建一套完全自由的操作系统。）</p>

<p>6、Ubuntu：Debian的后继一个分支。也是课程使用的linux发行版。</p>

<h3 id="toc_1">Ubuntu的优点</h3>

<p>1、简便易用。对于初学者，Ubuntu系统算是非常简单的，除了命令。</p>

<p>2、更新定期而频繁。每6个月就有一个新的Ubuntu版本，使用者非常多，支持的社区也很多。</p>

<p>3、标准化。</p>

<h3 id="toc_2">系统设置</h3>

<p><strong>lshw</strong>    获取硬件信息</p>

<p><strong>lscpu</strong>   获取CPU信息</p>

<p><strong>lsusb</strong>   获取usb接口信息</p>

<p><strong>uname</strong>   获取系统相关信息</p>

<p><strong>df</strong>  ：查看磁盘空间</p>

<p><strong>date</strong>    ：查看日期和时间</p>

<blockquote>
<p>&quot;+%j&quot; 今年中的第几天</p>
</blockquote>

<p><strong>hostname</strong>    ：显示主机名</p>

<p><strong>ifconfig</strong>    ：显示网络接口参数</p>

<h3 id="toc_3">关机重启命令</h3>

<p><strong>reboot</strong>  ：重启系统</p>

<p><strong>poweroff</strong>：   关机</p>

<p><strong>shutdown</strong>：   是定时关机</p>

<blockquote>
<p>shutdown -h time  指定时间，不写，就是一分钟之后执行</p>

<p>shutdown -h +5    ：五分钟后关机</p>

<p>shutdown -c   ：取消定时关机</p>

<p>shutdown -r now   ：立即重启</p>
</blockquote>

<h3 id="toc_4">常用指令</h3>

<pre class="line-numbers"><code class="language-python">#通过上下方向键来获取过往执行过的linux命令
#命令仅需输入前几位就可以用TAB键补全
要想准确，高效地完成各种任务，仅依赖命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数：
linux命令格式：
命令名称  [命令参数] [命令对象]
#命令名称、参数、对象之间用空格键分隔。

命令参数分为：
长格式  man --help
短格式  man -h

</code></pre>

<h3 id="toc_5">man 命令中常用按键以及用途</h3>

<table>
<thead>
<tr>
<th>按键</th>
<th>用处</th>
</tr>
</thead>

<tbody>
<tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>page down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>page up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>home（fn+左方向键）</td>
<td>直接前往首页</td>
</tr>
<tr>
<td>end（fn+右方向键）</td>
<td>直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td>从上至下搜索某个关键词，如 ‘/and’</td>
</tr>
<tr>
<td>?</td>
<td>从下至上搜索某个关键词，如 ‘？and’</td>
</tr>
<tr>
<td>n</td>
<td>定位到下一个搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td>定位到上一个搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td>退出帮助文档</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">目录命令</h3>

<p>1、pwd   ---print working directory</p>

<p>显示用户当前所处的工作目录</p>

<p>2、cd  ---change directory</p>

<p>用于切换工作路径</p>

<blockquote>
<p>cd 目录名  ：进入某一目录</p>

<p>cd ..    ：返回上一级目录，并显示路径</p>

<p>cd -   ：返回上一次所处的目录</p>

<p>cd ~     ：切换到当前用户的家目录</p>
</blockquote>

<p>3、ls ----list</p>

<p>ls会列举出当前工作目录的内容（文件或文件夹）</p>

<blockquote>
<p>-a    :查看所有文件（包括隐藏文件）</p>

<p>-l    ：查看文件的属性，大小等详细信息</p>
</blockquote>

<pre class="line-numbers"><code class="language-python">第一列一共十位：
#第一位是类型：
d代表目录
-代表是文件
l代表连接

#第二位到十位是权限
权限共九位，分三组，每三个一组
-rwx：
-r read 可读权限  4 或者 0
-w write 可写权限  2 或者 0  如果一条线，一个减号代表0
-x execute 可执行权限  1或者0

这三个字母能表示多少值:0-7
0：什么权限都没有
1：文件只能执行
2：文件只有写权限
3：文件可写可执行
4：文件只有读权限
5：可读可执行
6：可读可写
7：可读可写可执行

#对于文件而言：
可读权限表示允许读其内容，而禁止对其做任何的更改操作
可写权限表示可以改写编辑文件的内容或删除文件。（要有文件所在目录的写权限）
可执行权限表示允许将该文件作为一个程序执行。
#对于目录而言：
可读权限表示允许显示该目录中的内容
可写权限表示可以在目录中新建，删除，重名令文件
可执行权限表示可以进入该目录。可执行权限是基本权限。

权限共九位，每三个一组
1、代表当前用户的权限  ---读写和执行
2、代表当前用户所属的组的权限
3、代表其他组的权限

-w-


</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 开启自动驼峰转换]]></title>
    <link href="http://565785929.github.io/15826152154212.html"/>
    <updated>2020-02-25T15:20:15+08:00</updated>
    <id>http://565785929.github.io/15826152154212.html</id>
    <content type="html"><![CDATA[
<p>在mybatis-config.xml文件中加入此设置</p>
<?xml version="1.0" encoding="UTF-8" ?>
<p>&lt;!DOCTYPE configuration<br/><br/>
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;<br/><br/>
&quot;<a href="http://mybatis.org/dtd/mybatis-3-config.dtd%22%3E">http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</a><br/><br/>
<configuration><br/><br/>
    <settings><br/><br/>
        <setting name="mapUnderscoreToCamelCase" value="true" /><br/><br/>
    </settings><br/><br/>
</configuration></p>

<p><img src="media/15826152154212/15826153307445.jpg" alt=""/></p>

<p>参考:<br/>
<a href="https://yq.aliyun.com/articles/662319">https://yq.aliyun.com/articles/662319</a><br/>
<a href="https://www.cnblogs.com/pjfmeng/p/7677773.html">https://www.cnblogs.com/pjfmeng/p/7677773.html</a><br/>
<a href="https://www.cnblogs.com/zhouricong/p/9483099.html">https://www.cnblogs.com/zhouricong/p/9483099.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java和mysql转换]]></title>
    <link href="http://565785929.github.io/15823891714442.html"/>
    <updated>2020-02-23T00:32:51+08:00</updated>
    <id>http://565785929.github.io/15823891714442.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th>java类</th>
<th> </th>
<th>mysql数据库</th>
</tr>
</thead>

<tbody>
<tr>
<td>java.lang.Byte</td>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>java.lang.Short</td>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>java.lang.Integer</td>
<td>integer</td>
<td>INGEGER</td>
</tr>
<tr>
<td>java.lang.Long</td>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>java.lang.Float</td>
<td>float</td>
<td>FLOAT</td>
</tr>
<tr>
<td>java.lang.Double</td>
<td>double</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>java.lang.BigDecimal</td>
<td>big_decimal</td>
<td>NUMERIC</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>java.lang.String</td>
<td>string</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>yes_no</td>
<td>CHAR(1)(&#39;Y&#39;或&#39;N&#39;)</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>true_false</td>
<td>CHAR(1)(‘Y’或&#39;N&#39;)</td>
</tr>
<tr>
<td>java.uitl.Date</td>
<td>java.sql.Date</td>
<td>date</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.uitl.Calendar</td>
<td>celendar</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.uitl.Calendar</td>
<td>calendar</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.io.Serializable</td>
<td>serializable</td>
<td>VARBINARY/BLOB</td>
</tr>
<tr>
<td>java.sql.Clob</td>
<td>clob</td>
<td>CLOB</td>
</tr>
<tr>
<td>java.sql.Blob</td>
<td>blob</td>
<td>BLOB</td>
</tr>
<tr>
<td>java.lang.Class</td>
<td>class</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.Locale</td>
<td>locale</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.TimeZone</td>
<td>timezone</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.Currency</td>
<td>currency</td>
<td>VARCHAR</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 查看表注释或字段注释]]></title>
    <link href="http://565785929.github.io/15823882245344.html"/>
    <updated>2020-02-23T00:17:04+08:00</updated>
    <id>http://565785929.github.io/15823882245344.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">查看注释</h2>

<p>查看所有表的注释</p>

<pre class="line-numbers"><code class="language-sql">SELECT
table_name 表名,
table_comment 表说明
FROM
information_schema.TABLES
WHERE
table_schema = &#39;数据库名&#39;
ORDER BY
table_name
</code></pre>

<p>查询所有表及字段的注释</p>

<pre class="line-numbers"><code class="language-sql">SELECT
a.table_name 表名,
a.table_comment 表说明,
b.COLUMN_NAME 字段名,
b.column_comment 字段说明,
b.column_type 字段类型,
b.column_key 约束
FROM
information_schema.TABLES a
LEFT JOIN information_schema.COLUMNS b ON a.table_name = b.TABLE_NAME
WHERE
a.table_schema = &#39;数据库名&#39;
ORDER BY
a.table_name
</code></pre>

<p>查询某表的所有字段的注释</p>

<pre class="line-numbers"><code class="language-sql">select 
COLUMN_NAME 字段名,
column_comment 字段说明,
column_type 字段类型,
column_key 约束 from information_schema.columns 
where table_schema = &#39;数据库名&#39;
and table_name = &#39;表名&#39; ; 
</code></pre>

<p>或者</p>

<pre class="line-numbers"><code class="language-sql">show full columns from 表名;
</code></pre>

<h2 id="toc_1">查看表生成的DDL</h2>

<p><strong>注意表名不加单引号</strong></p>

<pre class="line-numbers"><code class="language-sql">show create table 表名;
</code></pre>

<h2 id="toc_2">新建表以及添加表和字段的注释</h2>

<pre class="line-numbers"><code class="language-sql">create table t_user(
    ID INT(19) primary key auto_increment  comment &#39;主键&#39;,
    NAME VARCHAR(300) comment &#39;姓名&#39;,
    CREATE_TIME date comment &#39;创建时间&#39;
)comment  = &#39;用户信息表&#39;;
</code></pre>

<h2 id="toc_3">修改表/字段的注释</h2>

<p>修改表注释</p>

<pre class="line-numbers"><code class="language-sql">alter table t_user comment  = &#39;修改后的表注释信息(用户信息表)&#39;;
</code></pre>

<p>修改字段注释</p>

<pre class="line-numbers"><code class="language-sql">alter table t_user modify column id int comment &#39;主键ID&#39;;
</code></pre>

<p>参考：简书<a href="https://www.jianshu.com/p/e6286174d35c">Mysql 查看表注释或字段注释</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易云 最嗨电音 爬虫]]></title>
    <link href="http://565785929.github.io/15819525546014.html"/>
    <updated>2020-02-17T23:15:54+08:00</updated>
    <id>http://565785929.github.io/15819525546014.html</id>
    <content type="html"><![CDATA[
<p>抓手机包找到音乐链接 Size最大</p>

<p><img src="media/15819525546014/15819533512601.jpg" alt="" style="width:1062px;"/></p>

<p>贴到浏览器发现可以打开，确实为此音乐</p>

<p><img src="media/15819525546014/15819534156184.jpg" alt="" style="width:546px;"/></p>

<p>筛选所有音乐链接 <code>m\d.music.126.net</code><br/>
<img src="media/15819525546014/15819537374098.jpg" alt="" style="width:1152px;"/></p>

<p>积攒一段时间，将这些链接拷贝到文件里<br/>
<img src="media/15819525546014/15819535577751.jpg" alt="" style="width:973px;"/></p>

<p>编写Python代码，统一下载</p>

<pre class="line-numbers"><code class="language-python">import requests
from urllib import request


class Electronic:

    def __init__(self) -&gt; None:
        self.s = requests.session()
        self.dir = &quot;music/&quot;
        self.file = &quot;music.txt&quot;

    def open_file(self):
        with open(self.file, &#39;r&#39;) as f:
            for number, line in enumerate(f, start=1):
                yield line

    def get_music(self, url, name):
        try:
            self.s.get(url)
            request.urlretrieve(url, name)
        except Exception as ex:
            print(url, ex)

    def start(self):
        for url in self.open_file():
            print(url)
            name = url.split(&#39;/&#39;)[-1].strip()
            self.get_music(url, self.dir + name)


if __name__ == &#39;__main__&#39;:

    e = Electronic()
    e.start()

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cheat.sh]]></title>
    <link href="http://565785929.github.io/15802234606202.html"/>
    <updated>2020-01-28T22:57:40+08:00</updated>
    <id>http://565785929.github.io/15802234606202.html</id>
    <content type="html"><![CDATA[
<p>cheat是在GNU通用公共许可证下，为Linux命令行用户发行的交互式备忘单应用程序。简单来说，它没有提供其他额外多余的信息，只通过使用实例告诉你一个命令参数如何使用。</p>

<h2 id="toc_0">使用</h2>

<p>它无需安装，提供网络查询方式，要从命令行获取UNIX / Linux命令的备忘单，请使用curl或任何其他在查询中指定命令名称的HTTP / HTTPS客户端来查询服务：</p>

<pre class="line-numbers"><code class="language-bash">    curl cheat.sh/tar
    curl cht.sh/curl
    curl https://cheat.sh/rsync
    curl https://cht.sh/tr
</code></pre>

<h2 id="toc_1">安装</h2>

<p>想离线使用，也可以安装客户端，非常简单<br/>
To install the client:</p>

<pre class="line-numbers"><code class="language-bash">    mkdir -p ~/bin/
    curl https://cht.sh/:cht.sh &gt; ~/bin/cht.sh
    chmod +x ~/bin/cht.sh
</code></pre>

<p>or to install it globally (for all users):</p>

<pre class="line-numbers"><code class="language-bash">    curl https://cht.sh/:cht.sh | sudo tee /usr/local/bin/cht.sh
    sudo chmod +x /usr/local/bin/cht.sh
</code></pre>

<p>之后也可以给cht.sh创建一个别名</p>

<p>client: <code>vi ~/.bashrc</code><br/>
globally: <code>sudo vi /etc/profile</code></p>

<p>在最后添加</p>

<pre class="line-numbers"><code class="language-text"># cheat
alias cht=cht.sh
</code></pre>

<p>重新加载一下配置文件<br/>
client: <code>source ~/.bashrc</code><br/>
globally: <code>source /etc/profile</code></p>

<p>之后可以使用cht获取命令示例<br/>
<img src="media/15802234606202/15802244400106.jpg" alt="" style="width:682px;"/></p>

<p>如果输出的不是你需要的答案，你可以选择带入参数， 例如/1, /2 :</p>

<pre class="line-numbers"><code class="language-text">    curl cht.sh/python/random+string
    curl cht.sh/python/random+string/1
    curl cht.sh/python/random+string/2
</code></pre>

<p><a href="https://github.com/chubin/cheat.sh">github</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crontab 定时任务]]></title>
    <link href="http://565785929.github.io/15776732342055.html"/>
    <updated>2019-12-30T10:33:54+08:00</updated>
    <id>http://565785929.github.io/15776732342055.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Linux</h3>

<p><img src="media/15776732342055/15776733247221.jpg" alt="" style="width:634px;"/></p>

<p>crontab -e <br/>
打开编辑表达式</p>

<p>表达式必须使用绝对路径</p>

<p>sudo systemctl restart crond.service<br/>
重启生效</p>

<p>crontab -l<br/>
查看所有定时任务表达式</p>

<h3 id="toc_1">cht</h3>

<p><img src="media/15776732342055/15826461147316.jpg" alt="" style="width:767px;"/></p>

<pre class="line-numbers"><code class="language-bash">&gt; cht crontab
# crontab
# Schedule cron jobs to run on a time interval for the current user.
# Job definition format: &quot;(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute&quot;.

# Edit the crontab file for the current user:
crontab -e

# Edit the crontab file for a specific user:
sudo crontab -e -u user

# View a list of existing cron jobs for current user:
crontab -l

# Remove all cron jobs for the current user:
crontab -r

# Sample job which runs at 10:00 every day (* means any value):
0 10 * * * command_to_execute

# Sample job which runs every minute on the 3rd of April:
* * 3 Apr * command_to_execute

# Sample job which runs a certain script at 02:30 every Friday:
30 2 * * Fri /absolute/path/to/script.sh
</code></pre>

]]></content>
  </entry>
  
</feed>
