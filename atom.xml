<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://blog.sajor.top/atom.xml" rel="self"/>
  <link href="http://blog.sajor.top/"/>
  <updated>2020-02-27T18:22:03+08:00</updated>
  <id>http://blog.sajor.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[MyBatis 开启自动驼峰转换]]></title>
    <link href="http://blog.sajor.top/15826152154212.html"/>
    <updated>2020-02-25T15:20:15+08:00</updated>
    <id>http://blog.sajor.top/15826152154212.html</id>
    <content type="html"><![CDATA[
<p>在mybatis-config.xml文件中加入此设置</p>
<?xml version="1.0" encoding="UTF-8" ?>
<p>&lt;!DOCTYPE configuration<br/><br/>
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;<br/><br/>
&quot;<a href="http://mybatis.org/dtd/mybatis-3-config.dtd%22%3E">http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</a><br/><br/>
<configuration><br/><br/>
    <settings><br/><br/>
        <setting name="mapUnderscoreToCamelCase" value="true" /><br/><br/>
    </settings><br/><br/>
</configuration></p>

<p><img src="media/15826152154212/15826153307445.jpg" alt=""/></p>

<p>参考:<br/>
<a href="https://yq.aliyun.com/articles/662319">https://yq.aliyun.com/articles/662319</a><br/>
<a href="https://www.cnblogs.com/pjfmeng/p/7677773.html">https://www.cnblogs.com/pjfmeng/p/7677773.html</a><br/>
<a href="https://www.cnblogs.com/zhouricong/p/9483099.html">https://www.cnblogs.com/zhouricong/p/9483099.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jdk]]></title>
    <link href="http://blog.sajor.top/15822108701088.html"/>
    <updated>2020-02-20T23:01:10+08:00</updated>
    <id>http://blog.sajor.top/15822108701088.html</id>
    <content type="html"><![CDATA[
<p>首先下载jdk，<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html">jdk下载页面</a></p>

<h2 id="toc_0">卸载原有jdk</h2>

<p>检查操作系统是否自带openjdk </p>

<p>输入<code>java -version</code>若出现java版本信息，表明操作系统目前自带的jdk，按以下方式进行卸载。</p>

<p>检查操作系统上自带的jdk <br/>
<code>rpm -qa|grep jdk</code> </p>

<p>如果显示jdk的相关信息，则继续，否则跳过这一步， 卸载原有的jdk <br/>
<code>yum remove java*</code></p>

<p>检索所有的java套件 <code>rpm -qa | grep java</code></p>

<p>如果显示：</p>

<pre><code class="language-text">java-x.x.x-openjdk-x.x.x.xxx-x.x.x.x.el7.x86_64
…
java-x.x.x-openjdk-headless-x.x.x.xxx-x.b14.el7.x86_64
…
</code></pre>

<p>则继续，否则跳过这一步。</p>

<p>删除所有包含有openjdk的套件</p>

<pre><code class="language-text">rpm -e --nodeps java-x.x.x-openjdk-x.x.x.xxx-x.x.x.x.el7.x86_64
rpm -e --nodeps java-x.x.x-openjdk-headless-x.x.x.xxx-x.b14.el7.x86_64
...
</code></pre>

<h2 id="toc_1">安装</h2>

<p>java安装文件夹准备</p>

<p>在/usr/local/目录下创建名称为java的文件夹：<br/>
<code>sudo mkdir -p /usr/local/java</code></p>

<p>将下载好的jdk安装包上传到服务器上。<br/>
之后解压到<code>/usr/local/java</code>中</p>

<p><code>sudo tar -zxvf jdk-8u241-linux-x64.tar.gz</code></p>

<h2 id="toc_2">配置</h2>

<p>编辑配置文件<code>sudo vim /etc/profile</code></p>

<p>定位到最后一行，添加如下内容（版本注意修改）</p>

<pre><code class="language-text"># jdk
export JAVA_HOME=/usr/local/java/jdk1.8.0_241/
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
</code></pre>

<p>之后重新加载此配置文件 <code>source /etc/profile</code></p>

<p>输入</p>

<pre><code class="language-text">java -version
javac -version
</code></pre>

<p>查看是否安装成功</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spark]]></title>
    <link href="http://blog.sajor.top/15822104759867.html"/>
    <updated>2020-02-20T22:54:35+08:00</updated>
    <id>http://blog.sajor.top/15822104759867.html</id>
    <content type="html"><![CDATA[
<p>首先到官网<code>spark.apache.org</code>下载spark，<a href="https://spark.apache.org/downloads.html">spark下载页面</a> </p>

<h2 id="toc_0">安装</h2>

<p>spark安装文件夹准备</p>

<p>在/usr/local/目录下创建名称为spark的文件夹：<br/>
<code>sudo mkdir -p /usr/local/spark</code></p>

<p>将下载好的spark安装包上传到服务器上。<br/>
之后解压到<code>/usr/local/spark</code>中</p>

<p><code>sudo tar -zxvf spark-2.4.5-bin-hadoop2.7.tgz</code></p>

<h2 id="toc_1">配置</h2>

<p>编辑配置文件<code>sudo vim /etc/profile</code></p>

<p>定位到最后一行，添加如下内容（版本注意修改）</p>

<pre><code class="language-text"># spark
export SPARK_HOME=/usr/local/spark/spark-2.4.5-bin-hadoop2.7/
export PATH=$PATH:$SPARK_HOME/bin
</code></pre>

<p>之后重新加载此配置文件 <code>source /etc/profile</code></p>

<p>输入</p>

<pre><code class="language-text">spark-shell
</code></pre>

<p>查看是否安装成功</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易云 最嗨电音 爬虫]]></title>
    <link href="http://blog.sajor.top/15819525546014.html"/>
    <updated>2020-02-17T23:15:54+08:00</updated>
    <id>http://blog.sajor.top/15819525546014.html</id>
    <content type="html"><![CDATA[
<p>抓手机包找到音乐链接 Size最大</p>

<p><img src="media/15819525546014/15819533512601.jpg" alt="" style="width:1062px;"/></p>

<p>贴到浏览器发现可以打开，确实为此音乐</p>

<p><img src="media/15819525546014/15819534156184.jpg" alt="" style="width:546px;"/></p>

<p>筛选所有音乐链接 <code>m\d.music.126.net</code><br/>
<img src="media/15819525546014/15819537374098.jpg" alt="" style="width:1152px;"/></p>

<p>积攒一段时间，将这些链接拷贝到文件里<br/>
<img src="media/15819525546014/15819535577751.jpg" alt="" style="width:973px;"/></p>

<p>编写Python代码，统一下载</p>

<pre><code class="language-python">import requests
from urllib import request


class Electronic:

    def __init__(self) -&gt; None:
        self.s = requests.session()
        self.dir = &quot;music/&quot;
        self.file = &quot;music.txt&quot;

    def open_file(self):
        with open(self.file, &#39;r&#39;) as f:
            for number, line in enumerate(f, start=1):
                yield line

    def get_music(self, url, name):
        try:
            self.s.get(url)
            request.urlretrieve(url, name)
        except Exception as ex:
            print(url, ex)

    def start(self):
        for url in self.open_file():
            print(url)
            name = url.split(&#39;/&#39;)[-1].strip()
            self.get_music(url, self.dir + name)


if __name__ == &#39;__main__&#39;:

    e = Electronic()
    e.start()

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用模拟退火来构造极值图]]></title>
    <link href="http://blog.sajor.top/15809082865015.html"/>
    <updated>2020-02-05T21:11:26+08:00</updated>
    <id>http://blog.sajor.top/15809082865015.html</id>
    <content type="html"><![CDATA[
<p>Author：P. Wang ∗, G.W. Dueck, S. MacMillan</p>

<ul>
<li>他研究的这个极图和我们的不太一样，我们是不含某一个，他是不含一系列的。</li>
<li>第一部分概述，第二部分数学理论，第三部分模拟退火引入程序，第四部分实验</li>
<li>他利用这些特点来让他的图的数量变少，也就是增加限制条件让图少点</li>
<li>第三部分他就用了模拟退火，他不是像我们一样列出所有的，他就是利用模拟退火找到个满足条件的全局最优解，但是这个结果有的时候和穷举可能不一样，可是大体上效果挺好</li>
</ul>

<h2 id="toc_0">名词解释</h2>

<ul>
<li><p>正则图（regular graph）：正则图是指各顶点的度均相同的无向简单图。<br/>
在图论中，正则图中每个顶点具有相同数量的邻点； 即每个顶点具有相同的度或价态。 正则的有向图也必须满足更多的条件，即每个顶点的内外自由度都要彼此相等。具有k个自由度的顶点的正则图被称为k度的k-正则图。 此外，奇数程度的正则图形将包含偶数个顶点。<br/>
<img src="media/15809082865015/15809945534836.jpg" alt=""/></p></li>
<li><p>笼子（cage）：在图论的数学领域里，笼子是一个正则图，其周长具有尽可能少的顶点。一个（r,g）笼就是说每一个顶点都正好有r个邻居，而且最短的环路是g。</p></li>
</ul>

<p>The only (3,5)-cage is the Petersen graph. <img src="media/15809082865015/15809194745456.png" alt=""/><br/>
The only (3,6)-cage is the Heawood graph.<br/>
<img src="media/15809082865015/15809953759482.jpg" alt=""/></p>

<p>The only (3,7)-cage is the McGee graph.<br/>
<img src="media/15809082865015/15809953875256.jpg" alt=""/></p>

<p>The only (3,8)-cage is the Tutte–Coxeter graph.<br/>
<img src="media/15809082865015/15809953993956.jpg" alt=""/></p>

<h3 id="toc_1">摘要</h3>

<p>图G中的最短环的长度为图G的周长；如果图G中没有环，我们认为这种图的周长是无穷大的。本文研究了v阶和周长至少为n+1的图中最多边数的值，用\(ex(v;\{C_3, C_4, ..., C_n\})\) 表示。我们将讨论图的一个重要的性质，即极图中度的分布。然后我们描述如何将此特性和模拟退火算法结合在一起，并用来开发可用于生成极图的算法。我们的算法是第一个可用于生成周长大于 5 的极图的算法，并在 \(n\ge6\) 时给出 \(ex(v;\{C_3, C_4, ..., C_n\})\) 的下界。</p>

<h3 id="toc_2">介绍</h3>

<p>我们将使用图论的符号[4]。我们认为所有的图都是简单的，即无向图，没有自循环和多个边。<br/>
图具有顶点集\(V(G)\)，边集\(E(G)\)，\(v(G)\)顶点和\(\varepsilon(G)\)边。我们使用\(\Delta(G)\)表示图G最大度，\(\delta(G)\)表示图G最小度。图G的度序列由 \(D = \{d_i | d表示度；i (1 \le i \le v) 表示度为d的图G中的定点数\}\)表示。令\(|D|\)作为D的基数。很明显，如果\(|D|=1\)，图G是一个正则图。我们说一个\(|D|\)较小的图\((|D| \lt o(\sqrt {v}))\)接近正则图。图G的周长是G中最短环的长度；如果图G没有环，我们认为这种图的周长是无穷大的。通过\(ex(v;\{C_3, C_4, ..., C_n\})\)，我们表示v阶图中最大的边数，并且周长至少有n+1；并通过\(EX(v;\{C_3, C_4, ..., C_n\})\)我们表示周长至少为n+1，有\(ex(v;\{C_3, C_4, ..., C_n\})\)条边的v阶所有图的集合。本文大部分内容中，我们考虑<br/>
\(EX(v;\{C_3, C_4 \})\)中的图，并将它们称为极图。我们将参考图\(EX(v;\{C_3, C_4, ..., C_n\})\)  周长\(\ge {n+1}\)的极图。</p>

<p>一个d-regular图，周长为g，且具有尽可能少顶点数图，记为(d,g)-cage.在Erdo ̋s 和 Sachs[4]证明了笼子存在后，他们对这些图进行了集中深入研究。通常很难找到笼子。Wong[23]在这个问题上有很好的调查论文。</p>

<p>在1975年，Erdo ̋s [10]提到了确定\(f(v)\)的值的问题，即v阶 最大边数的图的周长至少为5。<br/>
。。。。</p>

<p>在第二部分，我们将讨论在极图上发现的重要属性。然后第三部分，我们描述了如何将该特性与模拟退火算法相结合，以开发可用于生成极图的算法。第四部分，我们将介绍一些获得的成果。</p>

<h3 id="toc_3">度序列（degree sequence）</h3>

<p>对称性无处不在。我们看到许多自然形式的对称性。例如人类就是左右对称的，花朵是中心对称的，贝壳是螺旋对称和鱼鳞的平移对称。对称性在数学中也起着举足轻重的作用。从几何学到群论，再到图论中的顶点传递性和正则性。正则图构成了一个特别有趣的类。它们似乎捕获了一般图的大部分复杂性，有趣的例子比比皆是，Headwood图，Petersen图和Coxeter图。</p>

<p><strong>定理2.1</strong> 对于任何\(v\ge5\)的极图G，G中最多有一个度为1的顶点<br/>
<strong>证明</strong> </p>

<p><strong>定理2.2</strong> 存在\(v\ge5\)的极图G，最小度\(\delta(G)\ge2\)<br/>
<strong>证明</strong> </p>

<p><strong>定理2.3</strong> <br/>
<strong>证明</strong> </p>

<p><strong>定理2.4</strong><br/><br/>
<strong>证明</strong> </p>

<p><strong>定理2.5</strong> 对于任何图G \(\{C_3, C_4\}-free, v \ge \delta(G) \Delta(G)\)<br/>
<strong>证明</strong> </p>

<p><strong>猜想2.1</strong> 对于任何极值图G，\(\Delta(G) \le v/2\)<br/>
<strong>证明</strong> 根据定理2.1，最多有一个度为1的顶点。定理2.5的结果可以推广为\(v \ge 1 +\Delta(G) + \Delta(G)(2-1)-1 = 2\Delta(G)\)</p>

<h3 id="toc_4">模拟退火（Simulated annealing）</h3>

<p>模拟退火（SA）是组合优化问题的一种好的解决方法。此项技术的基本操作是移动，移动是从解决方案空间中的一个元素到另一个元素的过渡。在本文中，移动是指在两个随机生成的不相邻顶点之间插入一条边。如果此次插入所创建的图的周长小于等于n，则必须删除一些边。我们通过􏰉\(\varepsilon(G)\)的减少来定义移动的成本。每一步都会影响当前解决方案的成本。直观地讲，人们倾向于降低成本的举动，因为目标是采用最低或接近最低的成本的解决方案。但是，仅允许这种移动，最终的解决方案很可能是局部最小值，而不是绝对最小值。为了摆脱局部最小值，必须采取增加成本的措施。</p>

<p>在模拟退火中，随机选择预期移动。如果移动减少了成本，则可以接受。否则，它可接受概率为\(e^{-\Delta E/T}\)，其中\(T\)是温度，\(\Delta E\)是此预期移动将导致成本的增量。最初，\(T\)很大，几乎所有移动都被接受。随着T的减小，逐渐降低了对成本增加动作的接受。最终，系统将很少接受移动动作。系统将这种状态称为冻结状态。温度降低的顺序称为退火时间表。下一个温度通过\(T_{n+1}=\alpha{T_n}\)获得，其中􏰁\(\alpha\)是冷却速率。通常􏰁\(\alpha\)在0.75~0.98之间。</p>

<p>通常具有积极成本的移动会被概率\(e^{-\Delta E/T}\)接受。最初，我们使用这种方法不能有效地获取已知的极值图。在某些情况下，我们甚至无法获得已知的极值图。然后，我们检查了生成的图，发现其中大部分图的顶点有很高的度。实际上，这就是写第2节内容的动机。正如我们在第2节中发现的那样，极值图往往与正则图非常接近。我们修改了传统方法来提现极值图中的规律。我们不是随机选择一对不相邻的顶点，然后随机决定是否在它们之间添加边，而是添加一个程序以确保将边在图中均匀分布。</p>

<p>步骤一：<br/>
首先，我们将所有顶点按照其度数升序排序。<del>对于每对随机选择的不相邻顶点，我们将这对顶点的等级定义为度序列中度数较大的顶点的位置。</del> 其次，我们定义Prob 1 = 1 - (这对顶点的秩/\(v(G)\))而且如果Prob 1 大于一个随机生成的数字，这对顶点将被接受。这使具有较小度数的顶点有更好的机会在它们之间插入新边。模拟退火不直接通过序列中的秩来接受对，因此秩最小的顶点对不能保证一定被接受。其背后的原因是，在某些极值图中，几乎没有度数较小的顶点。例如，\(ex(11;\{C_3, C_4\}) = 16\)，它是Petersen图加上一个顶点，该顶点链接到Petersen图中的一个顶点。显然，如果模拟退火算法坚持在顶点上以最小的阶数添加边，那么它将无法构造它。实际上，该程序通过使用Prob 1 = 1 −\(（max \{d(x), d{y}\}/\lceil \sqrt{v} \rceil）\)，在我们的测试运行中会产生更好的结果，其中x和y是一对随机选择的不相邻的对顶点。它基于<strong>猜想2.1</strong>。</p>

<p>步骤二：<br/>
对于在步骤一中选择好的一对顶点，将在它们之间插入一条边。然后，我们使用广度优先搜索来找到它们之间的距离，并且如果距离小于\((n − 1)\)，则必须从度更大的顶点删除边，以便消除长度小于\(n\)的环。重复的从度较大的顶点删除边，直到这对儿顶点之间的距离大于或等于\((n − 1)\)。我们将生成的结果图称为\(G_{new}\)，将插入边之前的图称为\(G_{old}\)。我们定义\(cost = \varepsilon(G_{old}) - \varepsilon(G_{new}) = \Delta E, Prob 2 = e^{-\Delta E/T}\)  总是接受成本为负的边插入。否则，如果Prob 2 &gt; 在0到1之间随机生成的数字会被接受。</p>

<p>下面给出我们实现的伪代码。在内部循环中，随机选择移动。在每个温度水平上都接受有限数量的移动。我们使用\(20 ∗ |V (G)|\)作为限制。这意味着对于较大的图形，可以接受更多的移动。此外，在每个温度下尝试移动的次数都有限制。对于每个接受的动作，我们希望尝试不超过60个动作。一旦达到了可接受的最大移动次数或最大尝试次数，温度就会降低，并开始新的迭代。当接受的移动次数未达到最大水平（最大移动）超过给定数量的连续迭代时，该过程将停止。也就是说，如果接受的尝试移动次数少于60，则我们认为系统处于冻结状态。</p>

<pre><code class="language-text">anneal(G)
    temp = initial_temp = 1.0
    cool_rate = 0.95
    max_moves=20∗|V|
    max_attempted_moves = 60 ∗ max_moves
    max_frozen = 100
    frozen = 0
    best_count = 0 (the number of edges in the result graph)    
    while(frozen6 = max frozen)
        moves = attempted_moves = 0 
        while((moves6max moves) and (attempted_moves &lt;= max_attempted_moves))
            increment attempted_moves
            pick a random move (randomly select two non-adjacent vertices)  
            if the move is accepted by the two steps process
                increment moves 
                if(􏰈(Dold )&lt;=(Gnew ))
                    increment best_count 
            else restore Gold
        end while
        temp = temp ∗ cool_rate
        if(attempted_moves &gt; max_attempted_moves)
            increment frozen 
    else
            frozen = 0 
        end if
    end while 
end anneal
</code></pre>

<p><img src="media/15809082865015/15813452069915.jpg" alt=""/></p>

<p><img src="media/15809082865015/15811719484894.jpg" alt=""/><br/>
以下变量：初始温度(initial_temp)，冷却速率(cool_rate)，最大移动(max_moves)，最大尝试移动(max_attempted_moves)和最大冻结(max_frozen)的设置可能有所不同。通过实验和经验观察，我们得出了上面伪代码中所示的设置。这些变量的更改将影响结果和程序的执行时间。</p>

<h3 id="toc_5">结果</h3>

<p>表一给出了\(0 \le v \le 29\)，\(ex(v, \{C_3, C_4\})\)的精确值。我们在合理的时间内获得了它们。请注意，这些是\(ex(v, \{C_3, C_4\})\)的准确值，这些值已在[8]中得到了作者的证明。此外，\(v = 1; 2; 3; 5; 7; 8; 9; 10; 13; 15; 19; 20\)的极值图是唯一的。其中一些是著名的图，需要花费研究人员数年的时间才能获得。例如，如果\(v = 10\)，则该图为Petersen图，(3, 5)-cage，如果\(v = 18\)，则为Robertson图，(4, 5)-cage。这表明计算出的下限是好的。</p>

<p>在我们验证了我们的算法可以为具有较小周长的极图产生良好的结果之后，我们还针对较大周长的极图运行了它。例如，已知（参见[14]）\(ex(2n + 2; \{C_3, C_4, ..., C_n\}) = 2n + 4; ex(3n; {C_3, C_4, ..., C_n}）= 3n + 5\)。极值图的周长\(\ge n + 1\)。在上述两种情况下，通过运行我们的程序，它确实为\(n \ge 15\)提供了最佳解决方案。我们还使用它来验证Garnick在[13]中对周长较大的极值图提出的以下问题。</p>

<p>是否存在一个常数\(c\)，使得对于所有\(n \ge 5\)和所有\(v \ge cn\)，任何一个周长\(\ge n + 1\)的极值图的周长为\(n + 1\)？</p>

<h3 id="toc_6">References</h3>

<p>[1] C.R.J. Clapham, A. Flockart, J. Sheehan, Graphs without four-cycles, J. Graph Theory 13 (1989) 29–47.<br/>
[2] A.E. Brouwer, A.M. Cohen, A. Neumaier, Distance — Regular Graphs, Springer, Heidelberg, 1989.<br/>
[3] B. Bolloba􏰆s, Extremal Graph Theory, Academic Press, London, 1978.<br/>
[4] J.A. Bondy, U.S.R. Murty, Graph Theory with Applications, North-Holland, Amsterdam, 1976.<br/>
[5] J.A. Bondy, M. Simonovits, Cycles of even length in graphs, J. Combin. Theory Ser. B 16 (1974) 97–105.<br/>
[6] S. Kirkpatrick, C.D. Gellate Jr., M.P. Vecchi, Optimization of simulated annealing, Science 220 (1983) 671– 680.<br/>
[7] F.R.K. Chung, Constructing random-like graphs, in: B. Bollobas (Ed.), Probabilistic Combinatorics and its Applications, Amer. Math. Soc., Providence, RI, Vol. 1991.<br/>
[8] Y.H.H. Kwong, D.K. Garnick, F. Lazebnik, Extremal graphs without three-cycles or four-cycles, J. Graph Theory 17 (5) (1993) 633–645.<br/>
[9] P. Erdo ̋s, Some recent progress on extremal graphs in graph theory, Congres. Numer. 14 (1975) 3–14.<br/>
[10] P. Erdo ̋s, H. Sachs, Regula􏰇re graphen gegebener taillenweite me minimaler knotenzahl, Wiss. Z. Univ.<br/>
Halle Matrin Luther Univ. Halle-Wittenberg Math. — Natur 12 (1963) 251–257.<br/>
[11] Z. Fu ̋redi, On the number of edges of quadrilateral-free graphs, J. Combin. Theory Ser. B 68 (1996)<br/>
1–6.<br/>
[12] M.R. Garey, D.S. Johnson, Computer and Intractability, Freeman, New York, 1979.<br/>
[13] D.K. Garnick, N.A. Nieuwejaar, Non-isomorphic extremal graphs with three-cycles or four-cycles,<br/>
J. Combin. Math. Combin. Comput. 12 (1993) 33–56.<br/>
[14] F. Lazebnik, P. Wang, On the structure of extremal graphs of high girth, J. Graph Theory 26 (1997)<br/>
147–153.<br/>
[15] B.D. MaKay, http:==cs.anu.edu.au=people/bdm=.<br/>
[16] B.D. MaKay, Practicle graph isomorphism, Congres. Numer. 30 (1981) 45–87.<br/>
[17] P. Wang, G. Dueck, An algorithm to 􏰀nd the upper bound of the distance between graphs, J. Combin.<br/>
Math. Combin. Comput. 19 (1995) 97–107.<br/>
[18] I. Reiman, U􏰇ber ein problem von k. zarankiewicz, Acta Math. Acad. Sci. Hungar. 9 (1958) 169–279.<br/>
[19] R.W. Robinson, N.C. Wormald, Almost all cubic graphs are hamiltonian, Random Structures Algorithms<br/>
3 (1992) 117–225.<br/>
[20] M. Simonovits, Extremal graph theory, in: L.W. Beineke, R.J. Wilson (Eds.), Selected Topics in Graph<br/>
Theory, Vol. 2, Academic Press, London, 1993, pp. 161–200.<br/>
[21] F. Lazebnik, V.A. Ustimenko, A.J. Woldar, A new series of dense graphs of high girth, Bull. Amer.<br/>
Math. Soc. 32 (1) (1995) 73–79.<br/>
[22] P. Wang, An upper bound of the (n; 5)-cages, Ars Combin. 47 (1997) 121–128.<br/>
[23] P.K. Wong, Cages — a survey, J. Graph Theory 6 (1982) 1–22.</p>

<p><img src="media/15809082865015/15810919588257.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cheat.sh]]></title>
    <link href="http://blog.sajor.top/15802234606202.html"/>
    <updated>2020-01-28T22:57:40+08:00</updated>
    <id>http://blog.sajor.top/15802234606202.html</id>
    <content type="html"><![CDATA[
<p>cheat是在GNU通用公共许可证下，为Linux命令行用户发行的交互式备忘单应用程序。简单来说，它没有提供其他额外多余的信息，只通过使用实例告诉你一个命令参数如何使用。</p>

<h2 id="toc_0">使用</h2>

<p>它无需安装，提供网络查询方式，要从命令行获取UNIX / Linux命令的备忘单，请使用curl或任何其他在查询中指定命令名称的HTTP / HTTPS客户端来查询服务：</p>

<pre><code class="language-bash">    curl cheat.sh/tar
    curl cht.sh/curl
    curl https://cheat.sh/rsync
    curl https://cht.sh/tr
</code></pre>

<h2 id="toc_1">安装</h2>

<p>想离线使用，也可以安装客户端，非常简单<br/>
To install the client:</p>

<pre><code class="language-bash">    mkdir -p ~/bin/
    curl https://cht.sh/:cht.sh &gt; ~/bin/cht.sh
    chmod +x ~/bin/cht.sh
</code></pre>

<p>or to install it globally (for all users):</p>

<pre><code class="language-bash">    curl https://cht.sh/:cht.sh | sudo tee /usr/local/bin/cht.sh
    sudo chmod +x /usr/local/bin/cht.sh
</code></pre>

<p>之后也可以给cht.sh创建一个别名</p>

<p>client: <code>vi ~/.bashrc</code><br/>
globally: <code>sudo vi /etc/profile</code></p>

<p>在最后添加</p>

<pre><code class="language-text"># cheat
alias cht=cht.sh
</code></pre>

<p>重新加载一下配置文件<br/>
client: <code>source ~/.bashrc</code><br/>
globally: <code>source /etc/profile</code></p>

<p>之后可以使用cht获取命令示例<br/>
<img src="media/15802234606202/15802244400106.jpg" alt="" style="width:682px;"/></p>

<p>如果输出的不是你需要的答案，你可以选择带入参数， 例如/1, /2 :</p>

<pre><code class="language-text">    curl cht.sh/python/random+string
    curl cht.sh/python/random+string/1
    curl cht.sh/python/random+string/2
</code></pre>

<p><a href="https://github.com/chubin/cheat.sh">github</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crontab 定时任务]]></title>
    <link href="http://blog.sajor.top/15776732342055.html"/>
    <updated>2019-12-30T10:33:54+08:00</updated>
    <id>http://blog.sajor.top/15776732342055.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Linux</h3>

<p><img src="media/15776732342055/15776733247221.jpg" alt="" style="width:634px;"/></p>

<p>crontab -e <br/>
打开编辑表达式</p>

<p>表达式必须使用绝对路径</p>

<p>sudo systemctl restart crond.service<br/>
重启生效</p>

<p>crontab -l<br/>
查看所有定时任务表达式</p>

<h3 id="toc_1">cht</h3>

<p><img src="media/15776732342055/15826461147316.jpg" alt="" style="width:767px;"/></p>

<pre><code class="language-bash">&gt; cht crontab
# crontab
# Schedule cron jobs to run on a time interval for the current user.
# Job definition format: &quot;(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute&quot;.

# Edit the crontab file for the current user:
crontab -e

# Edit the crontab file for a specific user:
sudo crontab -e -u user

# View a list of existing cron jobs for current user:
crontab -l

# Remove all cron jobs for the current user:
crontab -r

# Sample job which runs at 10:00 every day (* means any value):
0 10 * * * command_to_execute

# Sample job which runs every minute on the 3rd of April:
* * 3 Apr * command_to_execute

# Sample job which runs a certain script at 02:30 every Friday:
30 2 * * Fri /absolute/path/to/script.sh
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[监控Python 运行]]></title>
    <link href="http://blog.sajor.top/15773499726644.html"/>
    <updated>2019-12-26T16:46:12+08:00</updated>
    <id>http://blog.sajor.top/15773499726644.html</id>
    <content type="html"><![CDATA[
<p>使用memory_profiler模块</p>

<p>memory_profiler模块用来基于逐行测量代码的内存使用。使用这个模块会让代码运行的更慢。</p>

<p>安装方法如下：<br/>
<code>pip install memory_profiler</code></p>

<p>另外，建议安装psutil包，这样memory_profile会运行的快一点：<br/>
<code>pip install psutil</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh]]></title>
    <link href="http://blog.sajor.top/15769921068601.html"/>
    <updated>2019-12-22T13:21:46+08:00</updated>
    <id>http://blog.sajor.top/15769921068601.html</id>
    <content type="html"><![CDATA[
<p>systemctl stop sshd.service <br/>
停止转发</p>

<p>lsof -i :80|grep -v &quot;PID&quot;|awk &#39;{print &quot;kill -9&quot;,$2}&#39;|sh<br/>
关闭80端口程序</p>

<p>pscp -r -l root -pw 5657 e:\htk 118.24.163.26:/root<br/>
e:\htk -&gt; /root 传送文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pscp]]></title>
    <link href="http://blog.sajor.top/15769920752565.html"/>
    <updated>2019-12-22T13:21:15+08:00</updated>
    <id>http://blog.sajor.top/15769920752565.html</id>
    <content type="html"><![CDATA[
<p>远程传输命令 </p>

<p>pscp和scp功能相同，但pscp同时支持windows下使用，它有效解 决了windows系统向linux服务器传输文件，而且它只有一个文件，即pscp.exe，建议将该文件放到C:\WINDOWS\system32 下面，这样就可以在任何地方调用该文件命令，你也可以放在任意你指定文件夹下。</p>

<p><img src="media/15769920752565/15802251740483.jpg" alt="" style="width:682px;"/></p>

<ol>
<li>环境变量改好后，在命令行下输入 pscp就可以拷文件了：</li>
</ol>

<p>命令格式：pscp localfile rootuser@remoteip:/fileDirectory</p>

<p>拷贝整个文件夹： pscp -r localDir rootuser@remoteip:/fileDirectory</p>

<p>如果是从linux拷贝文件，是同样的方法，只不过是把前后地址对换一下即可;</p>

<ol>
<li>比如我想把windows下e:\htk 整个目录的所有文件复制到linux /root目录下，命令如下：</li>
</ol>

<p><strong>pscp -r -l root -pw 1234567890 e:\htk 192.168.0.204:/root</strong></p>

<p>说明：</p>

<p>-r 复制目录下所有文件;</p>

<p>-l 对方机器(linux)的用户名(root);</p>

<p>-pw 密码(1234567890 );</p>

<p>e:\htk 源文件/文件夹的地址;</p>

<p>192.168.0.204:/root 目的文件/文件夹的地址。192.168.0.204为linux机器的ip地址。</p>

<ol>
<li>反过来，把linux soundRcg目录下的test.txt文件传输到windows e:\下，同样在windows命令行中敲入命令： </li>
</ol>

<p>*<em>pscp -l root -pw 1234567890 192.168.0.204:/soundRcg/test.txt E:*</em></p>

<p>备注：pscp似乎传输速度不是很快。</p>

<p>lsof -i :80|grep -v &quot;PID&quot;|awk &#39;{print &quot;kill -9&quot;,$2}&#39;|sh</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git]]></title>
    <link href="http://blog.sajor.top/15769919595310.html"/>
    <updated>2019-12-22T13:19:19+08:00</updated>
    <id>http://blog.sajor.top/15769919595310.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Git是分布式版本控制系统 自报家门</h3>

<p>git config --global user.name &quot;Sajor&quot;<br/>
git config --global user.email &quot;<a href="mailto:565785929@qq.com">565785929@qq.com</a>&quot;</p>

<h2 id="toc_1">一</h2>

<p>初始化一个Git仓库，使用git init命令。</p>

<p>添加文件到Git仓库，分两步：</p>

<p>第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；</p>

<p>第二步，使用命令git commit，完成。</p>

<h3 id="toc_2">windows中的换行符为 CRLF， 而在linux下的换行符为LF，所以在执行add . 时出现提示，解决办法：</h3>

<pre><code class="language-text">rm -rf .git  // 删除.git  
git config --global core.autocrlf false  //禁用自动转换    

git init    // 重新执行
git add .  
</code></pre>

<h3 id="toc_3">文件添加到仓库 add</h3>

<pre><code class="language-text">git add readme.txt     // filename = readme.txt
</code></pre>

<h3 id="toc_4">用命令 git commit 告诉Git 文件提交到仓库</h3>

<pre><code class="language-text">git commit -m &quot;wrote a readme file&quot; 
-m后面输入的是本次提交的说明
commit可以一次提交很多文件，所以你可以多次add不同的文件
</code></pre>

<hr/>

<h2 id="toc_5">二</h2>

<p>要随时掌握工作区的状态，使用git status命令。</p>

<p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p>

<h3 id="toc_6">git status 查看当前状态</h3>

<pre><code class="language-text">git status 
</code></pre>

<h3 id="toc_7">git diff 查看做了哪些修改</h3>

<pre><code class="language-text">git diff readme.txt    // filename = readme.txt
git diff    #是工作区(work dict)和暂存区(stage)的比较
git diff --cached    #是暂存区(stage)和分支(master)的比较（add之后）
</code></pre>

<hr/>

<h2 id="toc_8">三</h2>

<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>

<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>

<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>

<h3 id="toc_9">git log 显示从最近到最远的提交日志</h3>

<pre><code class="language-text">git log 
// --pretty=oneline参数 可以在一行显示
git log --pretty=oneline 
前面的是commit id（版本号）
</code></pre>

<h3 id="toc_10">回退版本</h3>

<pre><code class="language-text">git reset -- hard HEAD^  
// 上一个版本是HEAD^ , 上上一个版本就是HEAD^^, 往上100个是HEAD~100
</code></pre>

<h3 id="toc_11">再返回未来的版本可以用commit id 返回</h3>

<pre><code class="language-text">git reset --hard 3628164  // commit id = 3628164
</code></pre>

<h3 id="toc_12">git reflog 记录你的每一次命令</h3>

<pre><code class="language-text">git reflog  前面会加你的commit id
</code></pre>

<hr/>

<h2 id="toc_13">四</h2>

<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</p>

<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>

<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>

<p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>

<h3 id="toc_14">撤销工作区的修改</h3>

<pre><code class="language-text">git checkout -- readme.txt   // filename = readme.txt
</code></pre>

<h3 id="toc_15">撤销缓存区的提交</h3>

<pre><code class="language-text">git reset HEAD readme.txt   // filename = readme.txt
</code></pre>

<h3 id="toc_16">工作区删除</h3>

<pre><code class="language-text">rm test.txt
</code></pre>

<h3 id="toc_17">从版本库中删除该文件 git rm 删掉 并提交</h3>

<pre><code class="language-text">git rm test.txt    // filename = test.txt
git commit -m &quot;remove test.txt&quot;
</code></pre>

<h3 id="toc_18">也可以使用 git checkout 恢复</h3>

<pre><code class="language-text">git checkout -- test.txt
</code></pre>

<hr/>

<h2 id="toc_19">五</h2>

<p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>

<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>

<p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>

<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>

<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br/>
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>

<h3 id="toc_20">在GitHub 添加ssh秘钥</h3>

<pre><code class="language-text">ssh-keygen -t rsa    生成ssh秘钥 
cat C://Users/zzx/.ssh/id_rsa.pub   默认位置
</code></pre>

<h3 id="toc_21">推送到远程仓库</h3>

<pre><code class="language-text">git remote add origin git@github.com:565785929/learngit.git
git push -u origin master
</code></pre>

<h3 id="toc_22">本地做了提交再更新远程仓库</h3>

<pre><code class="language-text">git push origin master 
</code></pre>

<h3 id="toc_23">远程库已经准备好了 git clone克隆一个本地库</h3>

<pre><code class="language-text">git clone git@github.com:565785929/gitskills.git     // proname = gitskills
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币]]></title>
    <link href="http://blog.sajor.top/15769918912350.html"/>
    <updated>2019-12-22T13:18:11+08:00</updated>
    <id>http://blog.sajor.top/15769918912350.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">EC私钥 Elliptic Curve private key</h3>

<p>比特币私钥为一个256位的二进制随机大数 一共32字节（Random 256 bit integer）</p>

<p>比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。 </p>

<p>将256位二进制大数转为十六进制（每四位二进制数转为一位十六进制数）得到一个64位的十进制字符串，这就是ec私钥（95e7e1e73b70965d31c3e56121ce14dd4f88431c8d5e7645e8fb4a73ba72ad29）</p>

<p>提示比特币私钥空间的大小是2<sup>256，这是一个非常大的数字。用十进制表示的话，大约是10<sup>77，而可见宇宙被估计只含有10<sup>80个原子。</sup></sup></sup></p>

<h3 id="toc_1">WIF格式私钥 Wallet import format</h3>

<p>私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。不同的格式用在不同的场景下。十六进制和原始的二进制格式用在软件的内部，很少展示给用户看。WIF格式用在钱包之间密钥的输入和输出，也用于代表私钥的二维码（条形码）。</p>

<p>ec私钥转换成wif格式私钥需要经过以下几个步骤<br/>
主网： 在ec私钥前面添加版本号x80，再经过base58check。生成的字符串由5开头<br/>
测试网： 在ec私钥前面添加版本号xEF，再经过base58check。生成的字符串由9开头</p>

<h3 id="toc_2">WIF-compressed格式私钥</h3>

<p>现在广泛使用这种私钥，表示比特币地址是由压缩公钥生成的。故也成为“压缩格式私钥”，<br/>
实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包， 只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式 是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</p>

<p>ec私钥转换成wif-compressed格式私钥需要经过以下几个步骤<br/>
主网： 在ec私钥前面添加版本号x80，后面添加x01,再经过base58check。 生成的字符串由K或L开头<br/>
测试网： 在ec私钥前面添加版本号xEF，后面添加x01,再经过base58check。 生成的字符串由c开头</p>

<h1 id="toc_3">公钥</h1>

<p>公钥由私钥经过secp256k1椭圆曲线算法生成。<br/>
公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。<br/>
我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头。</p>

<h3 id="toc_4">普通公钥</h3>

<p>经过椭圆曲线加密算法生成一个（x, y）的坐标，公钥就是两个坐标点连接形成的字符串。</p>

<h3 id="toc_5">压缩公钥</h3>

<p>引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭据和支付比特币。每个公钥有520比特（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。</p>

<p>一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2 mod p = (x3 + 7) mod p得到y坐 标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所 需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。</p>

<p>未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲 线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在 x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</p>

<h1 id="toc_6">比特币地址</h1>

<p>地址为公钥的hash， 因为有压缩和未压缩的公钥两种格式，所以同一个私钥可以生成两个不同的公钥，两个不同的公钥可以推出两个不用的比特币地址，但是它们对应的私钥却是相同的。</p>

<h1 id="toc_7">总结</h1>

<p><img src="media/15769918912350/bitcoin_address.jpg" alt="bitcoin_address"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[brew update 缓慢]]></title>
    <link href="http://blog.sajor.top/15765692780377.html"/>
    <updated>2019-12-17T15:54:38+08:00</updated>
    <id>http://blog.sajor.top/15765692780377.html</id>
    <content type="html"><![CDATA[
<p>更新时 使用 --verbose命令可以看到运行情况</p>

<p><code>brew update --verbose</code></p>

<p>查看brew的当前源:<br/>
执行下面命令可以看到, brew的官方镜像源为: <a href="https://github.com/Homebrew/homebrew">https://github.com/Homebrew/homebrew</a></p>

<pre><code class="language-text">cd /usr/local/Homebrew
git remote -v
</code></pre>

<p>更改brew镜像源</p>

<pre><code class="language-text">cd /usr/local/Homebrew
git remote set-url origin git://mirrors.tuna.tsinghua.edu.cn/homebrew.git
</code></pre>

<p>可以选择下面镜像源中的一个 (第一个亲测可用)<br/>
清华镜像源: git://mirrors.tuna.tsinghua.edu.cn/homebrew.git<br/>
中科大镜像源: <a href="http://mirrors.ustc.edu.cn/homebrew.git">http://mirrors.ustc.edu.cn/homebrew.git</a></p>

<h2 id="toc_0">mirrors.tuna.tsinghua.edu.cn[0: 101.6.8.193]: errno=Operation timed out</h2>

<p>Homebrew 镜像使用帮助<br/>
注:该镜像是 Homebrew 的 formula 索引的镜像（即 brew update 时所更新内容）。本镜像站同时提供 Homebrew 二进制预编译包的镜像</p>

<p>替换现有上游</p>

<pre><code class="language-text">cd &quot;$(brew --repo)&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git
 
cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git
 
brew update
</code></pre>

<p>使用homebrew-science或者homebrew-python</p>

<pre><code class="language-text">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-science&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-science.git
 
cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-python&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-python.git
 
brew update
</code></pre>

<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a></p>

<p><a href="https://blog.csdn.net/poem_2010/article/details/85049044">https://blog.csdn.net/poem_2010/article/details/85049044</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis使用场景]]></title>
    <link href="http://blog.sajor.top/15754473183515.html"/>
    <updated>2019-12-04T16:15:18+08:00</updated>
    <id>http://blog.sajor.top/15754473183515.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">缓存数据</h2>

<p>最常用，对经常需要查询且变动不是很频繁的数据</p>

<h2 id="toc_1">排行榜应用</h2>

<p>利用Redis的有序集合zset，每次插入数据时自动调整顺序值，根据插入时的score值将value按一定顺序连续排列。</p>

<h2 id="toc_2">计数器应用</h2>

<p>利用Redis的incr、decr命令进行原子性操作，来构建计数系统<br/>
比如在一个web应用程序中，如果想知道用户在一年中每天的点击量，只要将用户id和相关日期信息作为键，并在每次用户点击页面时，执行一次自增操作即可。</p>

<h2 id="toc_3">数据去重</h2>

<p>当需要存储一个列表数据，又不希望出现重复数据时，可以使用Redis的Set数据结构<br/>
set内部实现是一个value永远是null的hashmap，通过hash计算的方式判断一个成员是否在集合内，从而进行快速排重。</p>

<h2 id="toc_4">队列应用</h2>

<p>使用Redis的list类型的lpush、rpop、lpop可实现</p>

<p><a href="https://mp.weixin.qq.com/s/No0YW65zLQ9Pq25ynqSzgQ">https://mp.weixin.qq.com/s/No0YW65zLQ9Pq25ynqSzgQ</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自建redis集群规范]]></title>
    <link href="http://blog.sajor.top/15754418238619.html"/>
    <updated>2019-12-04T14:43:43+08:00</updated>
    <id>http://blog.sajor.top/15754418238619.html</id>
    <content type="html"><![CDATA[
<ul>
<li>可靠性低：如果数据走云盘做高可靠存储容易受网络波动干扰，如果不走云盘宕机数据易丢失，自建多副本运维很复杂，而且Redis本身的断网导致的全量同步机制对网络和运维的要求极高；</li>
<li>可用性低：自建单副本无法保证可用性，多副本对心跳检查和链路切换要求极高，传统的sentinel有很多缺陷，在执行复杂的keys flushdb等命令时很容易造成误切和雪崩；</li>
<li>诸多限制：自建集群方案如redis cluster，codis也有诸多限制，redis cluster需要smart client和非常</li>
</ul>

<h2 id="toc_0">键值设计</h2>

<p>key名设计</p>

<p>可读性和可管理性</p>

<p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p>

<p>ugc:video:1</p>

<p>简洁性</p>

<p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p>

<p>user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。<br/>
不要包含特殊字符</p>

<p>反例：包含空格、换行、单双引号以及其他转义字符</p>

<p><a href="https://www.cnblogs.com/-wenli/p/10941249.html">完整阿里云Redis开发规范</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis 集群]]></title>
    <link href="http://blog.sajor.top/15754270430043.html"/>
    <updated>2019-12-04T10:37:23+08:00</updated>
    <id>http://blog.sajor.top/15754270430043.html</id>
    <content type="html"><![CDATA[
<p>首先安装redis<br/>
brew install redis</p>

<p>将/usr/local/redis/bin<br/>
建立redis-cluster文件夹，复制六份， 三主三备份， 分别叫redis01-redis-06<br/>
<img src="media/15662634729470/15663492850811.jpg" alt="" style="width:423px;"/></p>

<p>将每个文件夹中的redis.conf都修改一下<br/>
例如： redis01/redis.conf</p>

<pre><code class="language-text">port 7001

cluster-enabled yes

cluster-config-file  nodes_7001.conf  

cluster-node-timeout  15000 

pidfile  /var/run/redis_7001.pid
</code></pre>

<p>redis02-redis06 的配置文件参照01的配置，将其中7001都改为2-6即可。</p>

<p>编写bash脚本启动</p>

<pre><code class="language-text">./redis01/redis-server ./redis01/redis.conf
./redis02/redis-server ./redis02/redis.conf
./redis03/redis-server ./redis03/redis.conf
./redis04/redis-server ./redis04/redis.conf
./redis05/redis-server ./redis05/redis.conf
./redis06/redis-server ./redis06/redis.conf
</code></pre>

<p>运行后查看进程<br/>
ps -ef | grep redis<br/>
<img src="media/15662634729470/15663495776677.jpg" alt="" style="width:707px;"/></p>

<p>安装ruby<br/>
brew install ruby</p>

<p>到rubypems.org下载redis工具，也可以直接wget<br/>
brew install wget<br/>
wget <a href="http://rubygems.org/downloads/redis-3.3.0.gem">http://rubygems.org/downloads/redis-3.3.0.gem</a><br/>
gem install -l redis-3.3.0.gem</p>

<p>创建集群</p>

<pre><code class="language-text">./redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1
</code></pre>

<p>报错</p>

<blockquote>
<p>[ERR] Node 127.0.0.1:7001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.</p>
</blockquote>

<p>连接到每个redis 运行</p>

<p>flushdb</p>

<blockquote>
<p>Node is not empty</p>
</blockquote>

<p>运行fix</p>

<p>./redis-cli --cluster fix 127.0.0.1:7001</p>

<p>cluster命令</p>

<pre><code class="language-text">cluster info 
cluster nodes
</code></pre>

<p>参考：<a href="https://blog.csdn.net/qq_42815754/article/details/82912130">redis集群搭建（非常详细，适合新手）</a><br/>
<a href="https://www.jianshu.com/p/dfc6656d4287">Redis 5.0.3集群搭建</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux安全查找原因]]></title>
    <link href="http://blog.sajor.top/15753573808254.html"/>
    <updated>2019-12-03T15:16:20+08:00</updated>
    <id>http://blog.sajor.top/15753573808254.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">备份重要命令</h3>

<p>高手入侵可能会修改集群中的重要命令，例如：top、ps、kill等重要命令<br/>
建议备份好</p>

<p><a href="https://blog.csdn.net/xinxin_2011/article/details/84936581">Linux系统发现占用CPU达100%的进程并处理</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 新建用户和组命令]]></title>
    <link href="http://blog.sajor.top/15751320029536.html"/>
    <updated>2019-12-01T00:40:02+08:00</updated>
    <id>http://blog.sajor.top/15751320029536.html</id>
    <content type="html"><![CDATA[
<p>用户的角色是通过UID和GID识别的。</p>

<p>UID用户ID：相当于各为的身份证，在系统中是唯一的</p>

<p>GID组ID：相当于各为的家庭或者你们的学校。</p>

<h3 id="toc_0">新建用户及设置密码命令如下：</h3>

<pre><code class="language-text">useradd 【参数】 用户名

-g 属组
-u 设置uid
-m 创建家目录
-M 没有家目录
-G 指定属于多个组
-s 指定登录shell
-d 指定家目录
-c 注释
-D 改变它默认的属性
-e 指定的日期是帐号失效的日期,
</code></pre>

<h3 id="toc_1">新建用户及设置密码命令如下：</h3>

<pre><code class="language-text">passwd 参数 用户名

-l：锁定已经命名的账户名称
-u：解开账户锁定状态
-x, --maximum=DAYS：密码使用最大时间（天）
-n, --minimum=DAYS：密码使用最小时间（天）
-d：删除使用者的密码
-S：检查指定使用者的密码认证种类

--stdin：非交互式修改/设置密码，弊端是操作日志能查密码，需要用 history -c 干掉。
echo 123345|passwd --stdin 用户名
history -c
</code></pre>

<h3 id="toc_2">修改用户：</h3>

<pre><code class="language-text">usermod 参数 用户名

-c：修改用户帐号的备注文字。
-d：修改用户登入时的目录。
-e：修改帐号的有效期限。
-f： 改在密码过期后多少天即关闭该帐号。
-g：修改用户所属的群组。
-G：修改用户所属的附加群组。
-l：修改用户帐号名称。
-L：锁定用户密码，使密码无效。
-s：修改用户登入后所使用的shell。
-u：修改用户ID。
-U：解除密码锁定。

常用的参数包括-c， -d， -m， -g， -G， -s， -u以及-o等，与useradd命令中的选项一样，可以为用户指定新的资源值。
</code></pre>

<h3 id="toc_3">删除用户：</h3>

<pre><code class="language-text">userdel 参数 用户名

常用的选项是-r，它的作用是把用户的家目录一起删除。

userdel -r abc
</code></pre>

<h3 id="toc_4">创建用户组：</h3>

<pre><code class="language-text">groupadd  参数  用户组名

-g：指定新建用户组的gid；
-r：创建系统工作组，系统用户的组ID小于500；
-K：覆盖配置文件“/ect/login.defs”；
-o：允许添加组ID号不唯一的工作组。
</code></pre>

<h3 id="toc_5">修改组：</h3>

<pre><code class="language-text">groupmod 参数 用户组名

-g： GID 为用户组指定新的组标识号。
-o：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
-n：新用户组 将用户组的名字改为新名字
</code></pre>

<h3 id="toc_6">删除用户组：</h3>

<pre><code class="language-text">groupdel  用户名
</code></pre>

<h3 id="toc_7">用户查询相关命令：</h3>

<pre><code class="language-text">id   //查询用户信息，例如用户归属那个用户组，及uid和gid等。

w   //查看谁登录了，并且做了什么，切换的不行，从新登录的才行。

who  //查看哪些用户在登录，终端及登录时间，来源主机。

users  //仅显示哪些用户在登录。 

last   //显示的用户曾经加目前登录以及退出登录列表

lastlog  //可以查看是否有用户登录系统了（未启用的账户）
</code></pre>

<h3 id="toc_8">解决用userdel删除不掉用户的问题</h3>

<p>vipw命令<br/>
详情请看 vipw --help</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis 参数配置]]></title>
    <link href="http://blog.sajor.top/15749080605397.html"/>
    <updated>2019-11-28T10:27:40+08:00</updated>
    <id>http://blog.sajor.top/15749080605397.html</id>
    <content type="html"><![CDATA[
<ul>
<li>安装目录创建</li>
</ul>

<table>
<thead>
<tr>
<th>目录名</th>
<th>用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>/redis/bin</td>
<td>存放redis软件本体</td>
</tr>
<tr>
<td>/redis/conf</td>
<td>存放redis实例配置文件</td>
</tr>
<tr>
<td>/redis/logs</td>
<td>存放redis标准输出日志</td>
</tr>
<tr>
<td>/redis/backup</td>
<td>存放备节点配置文件，其他备份文件</td>
</tr>
<tr>
<td>/redis/var</td>
<td>存放redis进程文件</td>
</tr>
<tr>
<td>/redis/nodes</td>
<td>存放redis集群模式nodes配置文件</td>
</tr>
<tr>
<td>/redisdump</td>
<td>存放redis持久化数据，独立的文件系统</td>
</tr>
<tr>
<td>/redis/tmp</td>
<td>存放哨兵工作目录，redis集群最初配置状态</td>
</tr>
</tbody>
</table>

<p>执行转换文件权限命令：</p>

<pre><code class="language-text">chown -R redis:redisgrp
chomd -R 755
</code></pre>

<p>上述文件系统目录以及子目录所有属组为redis:redisgrp, 所有权限为755</p>

<p>注意： 如果开启redis持久化，需要单独创建另一文件系统/redisdump,将Redis的持久化数据放到该文件系统下。</p>

<ul>
<li>将Redis集群各成员的主机名/ip 映射信息加入到/etc/hosts当中</li>
</ul>

<h4 id="toc_0">集群配置（redis.conf重点参数配置）</h4>

<p>针对每个Redis 服务器的不同端口均需要单独存放配置文件（redis.conf）， 配置文件位置为/redis/conf/redis_[redis_port].conf，其中Redis端口建议使用7003以上端口，如部分系统使用软件较多存在端口冲突， 也可根据自身情况进行更改，但不建议使用7000以下端口。每个端口的配置文件均需满足如下配置要求：</p>

<pre><code class="language-text">daemonize yes     # daemonize no 配置redis以守护进程方式运行。
bind 本机ip
port 7003
pidfile /redis/var/redis_[redis_port].pid   # 修改pid文件位置及名称
logfile /redis/logs/redis_[redis_port].log  # 设置redis日志
loglevel notice                             # 设置redis的日志级别
stop-writes-on-bgsave-error no              # 设置节点bgsave操作时


</code></pre>

<ol>
<li>修改daemonize no 为 daemonize yes， 即配置redis以守护进程方式运行。</li>
<li>修改bind地址为本机IP地址</li>
<li>修改端口为指定端口，根据所进目录如port 7003</li>
<li>修改pid文件位置及名称pidfile /redis/var/redis_[redis_port].pid</li>
<li>设置redis日志，logfile /redis/logs/redis_[redis_port].log</li>
<li>设置redis的日志级别， loglevel notice</li>
<li>持久化功能：注意：持久化分为RDB和AOF两种模式，由于开启持久化会产生比较大的文件，例如：dump.rdb或appednonly.aof，造成IO读写性能下降，但同时，开启持久化是为了保障Redis数据的完备性，可以在宕机后及时回复所需数据，是Redis非常重要的备份恢复机制。因此持久化部分需要与项目协商讨论是否开启。</li>
<li>RDB持久化功能，如果Redis作为缓存服务器，建议关闭，尽量选择：
<code>
# save 900 1<br/>
# save 300 10<br/>
# save 60 10000
</code>
设置RDB的储存文件名为：<br/>
dbfilename &quot;dump_[redis_port].rdb&quot;<br/>
设置RDB储存路径为：<br/>
dir /redisdump</li>
<li>AOF持久化功能，默认建议关闭改功能，如需开启，请参考如下内容：<br/>
开启AOF选项：<br/>
appendonly yes<br/>
appendfilename &quot;/redis/dump/appendonly_[redis_port].aof&quot;</li>
<li>设置节点bgsave操作时，可以写操作stop-writes-on-bgsave-error no</li>
<li>设置重命名机制，禁止Redis系统上线后，客户端以及redis-cli端使用config、flushdb、flushall命令操作redis<br/>
rename-command CONFIG ADMCONFIG<br/>
rename-command FLUSHDB ADMFLUSHDB<br/>
rename-command FLUSHALL ADMFLUSHALL<br/>
rename-command KEYS ADMKEYS<br/>
注明：对于更换后的命令，例如ADMCONFIG等，可以由系统管理员自行指定更复杂命令。</li>
<li>根据系统内存情况，设置支持的最大内存数（最大内存数必须设置，依实际情况设置，该主机上的Redis最大内存总和不要超过物理内存的50%（如果该主机只独立部署Redis软件，该主机上的Redis最大内存总和不要超过物理内存的75%，建议maxmemory最大值不超过10G） maxmemory 10gb</li>
<li>设置达到最大内存后的内存清理策略（依实际情况设置）<br/>
如果数据可以淘汰，建议设置：maxmemory-policy allkeys-lru<br/>
如果数据不可淘汰，建议设置：maxmemory-policy noeviction</li>
<li><p>开启集群模式 cluster-enabled yes<br/>
如果开启集群模式建议设置：</p>
<ul>
<li>设置集群节点配置文件（启动自动生成） cluster-config-file /redis/nodes/nodes_[redis_port].conf</li>
<li>设置集群节点宕机时间（节点之间互相通信时，某主节点多少毫秒失去联系既被认为是该节点宕机） cluster-node-timeout 15000</li>
<li>设置cluster-migration-barrier X(X=每个主机节点上设计跟随的从节点数量)</li>
<li>设置cluster-require-full-coverage no(即部分节点宕机，其节点仍对外提供服务，默认不提供服务)</li>
</ul></li>
<li><p>为Redis集群设置访问密码（requirepass和masterauth都需要设置，否则发送主从切换时，就会遇到授权问题。（注意各个节点的密码都必须一致）<br/>
密码设置规范： 要求密码数超过10位；大小写、字母、数字、特殊字符（单双引号不要使用）相结合；不允许使用redis、root等敏感字符</p>
<pre><code class="language-text"># requirepass foobared 
修改为<br/>
requirepass ****<br/>
masterauth ****
</code></pre>
<p>注意： 使用redis-trib.rb工具构建集群，集群构建前不要设置密码，构建后通过config set + config rewrite 命令逐个机器设置密码，所以此步跳过。</p></li>
<li><p>修改复制客户端缓存区永不溢出</p>
<pre><code class="language-text">client-output-buffer-limit normal 0 0 0 
client-output-buffer-limit slave 0 0 0 
</code></pre></li>
<li><p>修改复制去backlog buffer大小： repl-backlog-size 30mb</p></li>
<li><p>修改配置文件属性，每台服务器的每个端口都需执行 chmod or-r /redis/conf/redis_[redis_port].conf</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis部署规范]]></title>
    <link href="http://blog.sajor.top/15748392035708.html"/>
    <updated>2019-11-27T15:20:03+08:00</updated>
    <id>http://blog.sajor.top/15748392035708.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<h3 id="toc_1">背景和目的</h3>

<p>为规范生产环境部署和资源规划，更好实施资源池管理策略。用于指导Redis产品的安装配置，Redis哨兵和集群模式创建</p>

<h3 id="toc_2">使用范围</h3>

<ul>
<li>适用对象： 系统规划设计人员、系统部署实施人员、系统维护人员、IT管理人员。</li>
<li>适用范围：</li>
<li>使用场景： 传统架构及PaaS平台均需遵守该规范</li>
<li>试用版本： 目前我行生产环境使用的所有Redis版本</li>
</ul>

<h3 id="toc_3">术语定义</h3>

<table>
<thead>
<tr>
<th>简称\术语</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>分布式缓存</td>
<td>为了提升指令和数据存取速度，通过分布式技术实现的缓存系统。</td>
</tr>
<tr>
<td>Redis</td>
<td>开源分布式缓存产品。网址：redis.io 使用C语言编写，支持网络、可基于内存有可以支持持久化的key-value数据缓存实现，并提供多种语言的API。</td>
</tr>
</tbody>
</table>

<h2 id="toc_4">本规范主要内容说明</h2>

<p>本文仅适用于Linux环境下的Redis产品部署</p>

<h2 id="toc_5">规范详细内容</h2>

<h3 id="toc_6">系统规划</h3>

<h4 id="toc_7">Redis版本选择</h4>

<p>没有特殊要求下，建议选择Redis4.0.10及之后版本</p>

<h4 id="toc_8">Redis架构选择</h4>

<p>Redis常用部署模式包括：</p>

<p>一. 集群模式：</p>

<p>集群模式下， 每个Redis组内包含至少一个Master主节点和至少一个它的Slave从节点。当发现某个Master节点不可用后，该Redis集群会发起投票机制重新选择一个它的Slave从节点作为主节点。</p>

<p><strong>使用要求</strong><br/>
使用单一操作系统物理内存80%不满足redis所承载应用需求，并且业务估算Redis使用内存高于10G，建议使用集群模式。</p>

<p><strong>生产环境集群架构部署要求</strong><br/>
对于A/A+类系统，至少使用“五个主节点十个从节点”（主节点分别部署到不同物理机上）的架构。根据业务要求，可以增加主节点数量，但主节点的总数量必须为奇数。对于高可用性要求较高的重点系统，可以加入备节点增加系统健壮性。</p>

<p>对于其他系统， 至少使用“三个主节点三个从节点”（主节点分别部署到不同物理机、虚拟机上）的架构。根据业务要求，可以增加主从节点数量，但主从节点的总数量必须为奇数。</p>

<p><strong>测试环境集群部署模式</strong><br/>
对于业务压力性能测试，需要与生产环境架构部署保持一致。<br/>
对于业务功能性测试，可以在满足业务功能性测试的条件下进行减配。</p>

<p>二. 哨兵模式</p>

<p>主从模式的升级版，通过监听sentinel端口状态，其中包含若干个Sentinel和Redis数据节点，每个Sentinel会对Redis数据节点和其余Sentinel进行监控，当发现Redis主节点不可达时，会对节点做下线表示，自动故障转移到从节点。</p>

<p><strong>使用要求</strong><br/>
单一操作系统物理内存80%可满足redis所承载应用需求，并且业务估算Redis使用内存低于10G，建议使用哨兵模式。</p>

<p><strong>生产环境集群架构部署要求</strong><br/>
对于A/A+类系统，至少使用三个哨兵节点（分别部署在不同机器上），且哨兵节点总数量必须为奇数；至少使用两个从节点（分别部署在不同机器上）</p>

<p><strong>测试环境集群部署模式</strong><br/>
对于业务压力性能测试，需要与生产环境架构部署保持一致。<br/>
对于业务性功能测试，可以在满足业务功能测试的条件下进行减配。</p>

<p>三. 单节点模式： 无高可用配置，原则上不允许生产环境使用。</p>

<h4 id="toc_9">Redis文件系统</h4>

<p>Redis文件系统： 为Redis创建单独的文件系统/redis。 大小建议至少为30GB，可扩容至100GB。</p>

<p>Redis持久化文件系统： Redis 需要生产 RDB 或开启 AOF 持久化机制，为Redis创建单独的文件系统/redisdump，用于存放Redis 产生的持久化文件。大小建议至少为该分区Redis主从节点数*15GB。</p>

<h3 id="toc_10">操作系统参数配置</h3>

<ul>
<li>关闭THP<br/>
&gt; echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br/>
&gt; 注意： 为了使机器重启后THP配置依然生效，可以在/etc/rc.local中追加上述命令</li>
<li>内存分配策略<br/>
&gt; vi /etc/sysctl.conf<br/>
&gt; 添加或更改vm.overcommit_memory = 1<br/>
&gt; sysctl -p</li>
<li>优化redis监听端口的队列长度<br/>
&gt; vi /etc/sysctl.conf<br/>
&gt; 添加或更改net.core.somaxconn = 30000<br/>
&gt; sysctl -p</li>
<li>针对can not open too many file问题的优化<br/>
&gt; 修改/etc/security/limits.conf<br/>
&gt; * soft nofile 65535<br/>
&gt; * hard nofile 65535</li>
</ul>

<h3 id="toc_11">Redis安装规范</h3>

<h4 id="toc_12">Redis安装准备</h4>

<ul>
<li>Redis用户\组</li>
</ul>

<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>标识</th>
<th>主组</th>
<th>主目录</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>redisgrp</td>
<td>组</td>
<td></td>
<td></td>
<td></td>
<td>redis用户组</td>
</tr>
<tr>
<td>redis</td>
<td>用户</td>
<td></td>
<td>redis</td>
<td>/redis</td>
<td>redis用户</td>
</tr>
</tbody>
</table>

<ul>
<li>Redis软件包： 需准备Redis 软件安装包及Redis依赖软件Ruby、gem-redis安装包。</li>
<li>安装目录创建</li>
</ul>

<table>
<thead>
<tr>
<th>目录名</th>
<th>用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>/redis/bin</td>
<td>存放redis软件本体</td>
</tr>
<tr>
<td>/redis/conf</td>
<td>存放redis实例配置文件</td>
</tr>
<tr>
<td>/redis/logs</td>
<td>存放redis标准输出日志</td>
</tr>
<tr>
<td>/redis/backup</td>
<td>存放备节点配置文件，其他备份文件</td>
</tr>
<tr>
<td>/redis/var</td>
<td>存放redis进程文件</td>
</tr>
<tr>
<td>/redis/nodes</td>
<td>存放redis集群模式nodes配置文件</td>
</tr>
<tr>
<td>/redisdump</td>
<td>存放redis持久化数据，独立的文件系统</td>
</tr>
<tr>
<td>/redis/tmp</td>
<td>存放哨兵工作目录，redis集群最初配置状态</td>
</tr>
</tbody>
</table>

<p>执行转换文件权限命令：</p>

<pre><code class="language-text">chown -R redis:redisgrp
chomd -R 755
</code></pre>

<p>上述文件系统目录以及子目录所有属组为redis:redisgrp, 所有权限为755</p>

<p>注意： 如果开启redis持久化，需要单独创建另一文件系统/redisdump,将Redis的持久化数据放到该文件系统下。</p>

<ul>
<li>将Redis集群各成员的主机名/ip 映射信息加入到/etc/hosts当中</li>
</ul>

<h4 id="toc_13">安装Redis依赖软件包</h4>

<p>部署Redis集群时需要用到一个管理Redis集群的工具redis-trib.rb，它是基于Redis提供的集群命令封装成简单、便捷、实用的操作工具，redis-trib.rb是用ruby完成的，所以redis集群需要先安装ruby环境。</p>

<p>使用redis用户安装（也可通过root用户安装后整体赋权给redisadm用户）分别安装Ruby、gem-redis两个组件，推荐使用官方rpm包安装。</p>

<p>注意： 在安装rubygem时，需要zlib-devel以及openssl-devel组件，请提前检查操作系统是否有相关组件。</p>

<h4 id="toc_14">安装redis</h4>

<p>安装要求： 通过root安装后整体赋权给redis用户，推荐使用源码进行编译安装。</p>

<h3 id="toc_15">集群模式配置规范</h3>

<h4 id="toc_16">集群设计要求</h4>

<ul>
<li>提前设计好集群架构， 分配好主节点和从节点架构关系。</li>
<li>集群主节点不能跟其从节点在同一台机器上。</li>
<li>开通主从节点的网络通信，确保主从节点的redis_port以及10000+redis_port 可以互相telnet通。</li>
<li>端口设置：所有主节点，无论是否在同一机器上，端口不能重复，需要从7003开始，依次递增，其从节点的端口与主节点保持一致。</li>
<li>配置结束后，将cluster nodes 的节点出事状态，记录到backup目录当中
<code>redis-cli -h redis_ip -p redis_port cluster nodes &gt; /redis/bacnup/nodestats.txt</code></li>
<li>配置结束后，执行命令，将Redis出事状态进行备份：<code>tar cf /redis/redis_all.tar bin nodes conf logs tmp var backup</code></li>
</ul>

<h4 id="toc_17">集群配置（redis.conf重点参数配置）</h4>

<p>针对每个Redis 服务器的不同端口均需要单独存放配置文件（redis.conf）， 配置文件位置为/redis/conf/redis_[redis_port].conf，其中Redis端口建议使用7003以上端口，如部分系统使用软件较多存在端口冲突， 也可根据自身情况进行更改，但不建议使用7000以下端口。每个端口的配置文件均需满足如下配置要求：</p>

<ol>
<li>修改daemonize no 为 daemonize yes， 即配置redis以守护进程方式运行。</li>
<li>修改bind地址为本机IP地址</li>
<li>修改端口为指定端口，根据所进目录如port 7003</li>
<li>修改pid文件位置及名称pidfile /redis/var/redis_[redis_port].pid</li>
<li>设置redis日志，logfile /redis/logs/redis_[redis_port].log</li>
<li>设置redis的日志级别， loglevel notice</li>
<li>持久化功能：注意：持久化分为RDB和AOF两种模式，由于开启持久化会产生比较大的文件，例如：dump.rdb或appednonly.aof，造成IO读写性能下降，但同时，开启持久化是为了保障Redis数据的完备性，可以在宕机后及时回复所需数据，是Redis非常重要的备份恢复机制。因此持久化部分需要与项目协商讨论是否开启。</li>
<li>RDB持久化功能，如果Redis作为缓存服务器，建议关闭，尽量选择：
<code>
# save 900 1<br/>
# save 300 10<br/>
# save 60 10000
</code>
设置RDB的储存文件名为：<br/>
dbfilename &quot;dump_[redis_port].rdb&quot;<br/>
设置RDB储存路径为：<br/>
dir /redisdump</li>
<li>AOF持久化功能，默认建议关闭改功能，如需开启，请参考如下内容：<br/>
开启AOF选项：<br/>
appendonly yes<br/>
appendfilename &quot;/redis/dump/appendonly_[redis_port].aof&quot;</li>
<li>设置节点bgsave操作时，可以写操作stop-writes-on-bgsave-error no</li>
<li>设置重命名机制，禁止Redis系统上线后，客户端以及redis-cli端使用config、flushdb、flushall命令操作redis<br/>
rename-command CONFIG ADMCONFIG<br/>
rename-command FLUSHDB ADMFLUSHDB<br/>
rename-command FLUSHALL ADMFLUSHALL<br/>
rename-command KEYS ADMKEYS<br/>
注明：对于更换后的命令，例如ADMCONFIG等，可以由系统管理员自行指定更复杂命令。</li>
<li>根据系统内存情况，设置支持的最大内存数（最大内存数必须设置，依实际情况设置，该主机上的Redis最大内存总和不要超过物理内存的50%（如果该主机只独立部署Redis软件，该主机上的Redis最大内存总和不要超过物理内存的75%，建议maxmemory最大值不超过10G） maxmemory 10gb</li>
<li>设置达到最大内存后的内存清理策略（依实际情况设置）<br/>
如果数据可以淘汰，建议设置：maxmemory-policy allkeys-lru<br/>
如果数据不可淘汰，建议设置：maxmemory-policy noeviction</li>
<li><p>开启集群模式 cluster-enabled yes<br/>
如果开启集群模式建议设置：</p>
<ul>
<li>设置集群节点配置文件（启动自动生成） cluster-config-file /redis/nodes/nodes_[redis_port].conf</li>
<li>设置集群节点宕机时间（节点之间互相通信时，某主节点多少毫秒失去联系既被认为是该节点宕机） cluster-node-timeout 15000</li>
<li>设置cluster-migration-barrier X(X=每个主机节点上设计跟随的从节点数量)</li>
<li>设置cluster-require-full-coverage no(即部分节点宕机，其节点仍对外提供服务，默认不提供服务)</li>
</ul></li>
<li><p>为Redis集群设置访问密码（requirepass和masterauth都需要设置，否则发送主从切换时，就会遇到授权问题。（注意各个节点的密码都必须一致）<br/>
密码设置规范： 要求密码数超过10位；大小写、字母、数字、特殊字符（单双引号不要使用）相结合；不允许使用redis、root等敏感字符</p>
<pre><code class="language-text"># requirepass foobared 
修改为<br/>
requirepass ****<br/>
masterauth ****
</code></pre>
<p>注意： 使用redis-trib.rb工具构建集群，集群构建前不要设置密码，构建后通过config set + config rewrite 命令逐个机器设置密码，所以此步跳过。</p></li>
<li><p>修改复制客户端缓存区永不溢出</p>
<pre><code class="language-text">client-output-buffer-limit normal 0 0 0 
client-output-buffer-limit slave 0 0 0 
</code></pre></li>
<li><p>修改复制去backlog buffer大小： repl-backlog-size 30mb</p></li>
<li><p>修改配置文件属性，每台服务器的每个端口都需执行 chmod or-r /redis/conf/redis_[redis_port].conf</p></li>
</ol>

<h3 id="toc_18">集群搭建步骤</h3>

<h4 id="toc_19">使用redis-trib.rb脚本搭建集群</h4>

<ol>
<li>按照《运维规范》启动所有Redis节点</li>
<li>只需在其中一台服务器上执行创建集群命令（命令中具体ip以实际情况为准）： 
<code>
redis-trib.rb create --replicas 1 192.168.1.1:7001 1 192.168.1.1:7002 1 192.168.1.2:7001 1 192.168.1.2:7002 1 192.168.1.3:7001 1 192.168.1.3:7002 <br/>
解释说明： redis-trib.rb create 是创建命令：
</code> </li>
<li></li>
</ol>

]]></content>
  </entry>
  
</feed>
