<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sajor's Blog]]></title>
  <link href="http://565785929.github.io/atom.xml" rel="self"/>
  <link href="http://565785929.github.io/"/>
  <updated>2021-04-24T23:59:09+08:00</updated>
  <id>http://565785929.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[自动登录工具开发]]></title>
    <link href="http://565785929.github.io/16110385786886.html"/>
    <updated>2021-01-19T14:42:58+08:00</updated>
    <id>http://565785929.github.io/16110385786886.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">涉及工具技术</h2>

<ul>
<li>Tampermonkey</li>
<li>jQuery</li>
<li>Tesseract-OCR</li>
<li>Flask</li>
<li><a href="https://pillow.readthedocs.io/en/stable/">Pillow</a></li>
</ul>

<h2 id="toc_1">前言</h2>

<p>开发软件系统时必然会有用户登陆的模块。每次验证自己的功能时，总是绕不开输入账号密码，这已经是很麻烦的了，还得输入不好辨认的验证码。</p>

<p>为了简化登陆步骤，我通过使用图像识别 OCR 技术，和Web应用框架Flask搭建一个验证码自动识别的服务。并结合强大的浏览器插件Tampermonkey，编写一个简单的油猴脚本，在不入侵源系统的基础上，实现不输入验证码登陆。也为后期自动化测试奠定可操作的基础。</p>

<h2 id="toc_2">依赖安装</h2>

<p>示例环境Centos8</p>

<pre class="line-numbers"><code class="language-bash">sudo yum install epel-release
sudo yum install tesseract-devel leptonica-devel
 
yum install -y libjpeg-devel  libpng-devel
yum install -y autoconf automake libtool

yum install -y git wget
yum install -y gcc gcc-c++
yum install -y tesseract  tesseract-devel  
yum install -y python36
</code></pre>

<p>创建python虚拟环境</p>

<pre class="line-numbers"><code class="language-bash">python3.6 -m venv py36env
source py36env/bin/activate
</code></pre>

<p>python依赖安装</p>

<pre class="line-numbers"><code class="language-bash">pip install flask
pip install flask_cors
pip install tesserocr
pip install pillow
pip install uwsgi
</code></pre>

<h2 id="toc_3">安装常见错误</h2>

<p><strong>找不到tesseract包</strong></p>

<blockquote>
<p>yum list tesseract <br/>
无数据 </p>
</blockquote>

<p><strong>解决</strong></p>

<pre class="line-numbers"><code class="language-text">yum -y install yum-utils
yum-config-manager --add-repo https://download.opensuse.org/repositories/home:/Alexander_Pozdnyakov/CentOS_8/
</code></pre>

<p><strong>TESSDATA_PREFIX问题</strong></p>

<blockquote>
<p>[Sajor@10-7-151-243 AutoLogin]$ tesseract captcha_denoising.png result <br/>
Error opening data file /usr/share/tesseract/4/tessdata/eng.traineddata<br/>
Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory.<br/>
Failed loading language &#39;eng&#39;<br/>
Tesseract couldn&#39;t load any languages!<br/>
Could not initialize tesseract.</p>
</blockquote>

<p><strong>解决</strong></p>

<p>搜索tessdata文件夹 </p>

<pre class="line-numbers"><code class="language-text">find / -type d -iname &quot;tessdata&quot;
</code></pre>

<p>发现确实没有 <code>eng.traineddata</code> 文件，则下载一个。</p>

<pre class="line-numbers"><code class="language-text">wget https://github.com/tesseract-ocr/tessdata/raw/master/eng.traineddata

sudo mv -v eng.traineddata /usr/local/share/tessdata/
</code></pre>

<h2 id="toc_4">验证码识别</h2>

<p>我们开发的系统登陆页面是这样的</p>

<p><img src="media/16110385786886/16110394454445.jpg" alt="" style="width:814px;"/></p>

<p>其中验证码图片<br/>
<img src="media/16110385786886/captcha3.png" alt="captcha3"/></p>

<p>先分析此验证码图片有以下特点</p>

<ul>
<li>颜色多样</li>
<li>字母较大，干扰线细</li>
<li>线条笔直无扭曲</li>
</ul>

<p>我们可以这样处理</p>

<h3 id="toc_5">颜色多样</h3>

<p>针对颜色多样，我们可以先给图片做灰度处理再做二值化处理，这是识别前处理验证码的基操。</p>

<blockquote>
<p><strong>灰度图像</strong>: 每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。<br/>
<strong>转换公式</strong>: <code>L = R * 299/1000 + G * 587/1000+ B * 114/1000</code></p>
</blockquote>

<pre class="line-numbers"><code class="language-text">from PIL import Image
image = Image.open(file).convert(&#39;L&#39;)
</code></pre>

<p><img src="media/16110385786886/16110398931116.jpg" alt="" style="width:323px;"/></p>

<p>之后对灰度图片做二值化，使图片非黑即白，可以通过调整下图中<code>threshold</code>的值来过滤少部分颜色浅的干扰线，因为图片中字母部分也可能出现亮黄色的情况，为了防止误删要识别的文字，我将阈值先调高一些，少过滤一些颜色。</p>

<blockquote>
<p><strong>二值图像</strong>: 非黑即白。每个像素用8个bit表示，0表示黑，255表示白。</p>

<pre class="line-numbers"><code class="language-text">image.convert(&#39;1&#39;)
</code></pre>
</blockquote>

<p><img src="media/16110385786886/16110403706745.jpg" alt="" style="width:523px;"/></p>

<h3 id="toc_6">字母较大，干扰线细</h3>

<p>因为字母较大，像素较多，而干扰线的较细，我们可以使用这个策略来去除干扰线。</p>

<pre class="line-numbers"><code class="language-text">遍历图片中每一个像素点：
    如果这个像素点为黑色：
        观察它四面八方的像素点颜色，如果少于四个点为黑色：
            将这个点变为白色
</code></pre>

<p>这个策略的大致意思就是将图像中置于边缘的像素删除掉。因为字母较大，像素比较多，删除一圈也不会有什么影响。</p>

<p><img src="media/16110385786886/16110409153447.jpg" alt="" style="width:310px;"/></p>

<h3 id="toc_7">线条笔直无扭曲</h3>

<p>通过上一步的降噪处理得到的结果已经很好了，因为线条笔直没有扭曲，可以直接丢给OCR来识别了！</p>

<p>网络中现成的OCR识别工具有很多，比如百度OCR，Tesseract-OCR。</p>

<p>第三方的OCR得经过注册，使用他们提供的token调用接口，我就直接使用Python的第三方库Tesseract来搞。</p>

<p>安装必要的包之后直接调用即可。</p>

<pre class="line-numbers"><code class="language-text">import tesserocr
result = tesserocr.image_to_text(image)
</code></pre>

<p><img src="media/16110385786886/16110413762073.jpg" alt="" style="width:360px;"/></p>

<h2 id="toc_8">编写Web接口</h2>

<p>使用Jupyter notebook 验证好功能后，将代码封装成类，方便调用。</p>

<p>之后使用Flask的 helloworld 工程简单修改一下，实现一个可调用的接口。</p>

<p>简单实用<code>uwsgi</code>部署一下这个web项目，配置<code>uwsgi.ini</code>文件将下文中<code>/root/AutoLogin</code>路径改为自己的目录。</p>

<pre class="line-numbers"><code class="language-text">[uwsgi]
master = true
http=:5000
chdir = /root/AutoLogin
wsgi-file=/root/AutoLogin/app.py
callable=app
processes=4
threads=2
buffer-size = 65536
vacuum=true
pidfile =/root/AutoLogin/uwsgi.pid
</code></pre>

<p>启动命令：<br/>
<code>uwsgi --ini uwsgi.ini</code><br/>
重启命令：<br/>
<code>uwsgi --reload uwsgi.pid</code><br/>
关闭命令：<br/>
<code>uwsgi --stop uwsgi.pid</code></p>

<h2 id="toc_9">NginX代理</h2>

<p>新建一个配置文件</p>

<pre class="line-numbers"><code class="language-text">vi /etc/nginx/conf.d/autologin.conf
</code></pre>

<p>输入以下内容</p>

<pre class="line-numbers"><code class="language-text">        server{

                listen       80;
                listen       [::]:80;
                server_name  autoLogin.sajor.top;
                access_log  /var/log/nginx/access.log;
                error_log   /var/log/nginx/error.log;

                location /{
                        proxy_pass http://localhost:5000;
                }
        }
</code></pre>

<p>检查并重启</p>

<pre class="line-numbers"><code class="language-text">nginx -t
service nginx restart
</code></pre>

<p>查看 mem top 10</p>

<pre class="line-numbers"><code class="language-text">ps aux | grep -v PID | sort -rn -k 4| head
</code></pre>

<h2 id="toc_10">--</h2>

<p>-- 未完待续。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql5.7 无法设置0000-00-00默认日期]]></title>
    <link href="http://565785929.github.io/16022150270617.html"/>
    <updated>2020-10-09T11:43:47+08:00</updated>
    <id>http://565785929.github.io/16022150270617.html</id>
    <content type="html"><![CDATA[
<p>问题：<br/>
<img src="media/16022150270617/16125316270697.jpg" alt=""/></p>

<p><img src="media/16022150270617/16125316380058.jpg" alt=""/></p>

<p>使用命令行。navicat不好使</p>

<h2 id="toc_0">解决方案：</h2>

<p>使用root登陆数据库</p>

<ol>
<li>查看sql_mode：
<code>select @@sql_mode;</code></li>
</ol>

<p>获得结果：<br/>
<code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>

<ol>
<li>NO_ZERO_IN_DATE,NO_ZERO_DATE是无法默认为‘0000-00-00 00:00:00’的根源，去掉之后再次新建表就可以了</li>
</ol>

<p><code>SET GLOBAL sql_mode=&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</code></p>

<h2 id="toc_1">注：</h2>

<p>NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零<br/>
NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p>

<p>测试新建表，ok。可以了。</p>

<h2 id="toc_2">终极解决方案</h2>

<p>修改my.ini配置文件直接修改启动sql_mode<br/>
在[mysqld]下添加<br/>
可以设置<code>sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>

<p>或者为了避免group by限制 直接设置为<code>STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION</code></p>

<pre class="line-numbers"><code class="language-text">[mysqld]
sql_mode=STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION
</code></pre>

<p>dos命令重启mysql</p>

<pre class="line-numbers"><code class="language-dos">net stop mysql
net start mysql
</code></pre>

<p><img src="media/16022150270617/16125316826946.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yum安装提示错误Thread/process failed: Thread died in Berkeley DB librar]]></title>
    <link href="http://565785929.github.io/15914577057463.html"/>
    <updated>2020-06-06T23:35:05+08:00</updated>
    <id>http://565785929.github.io/15914577057463.html</id>
    <content type="html"><![CDATA[
<p>问题描述：#<br/>
yum 安装更新提示 rpmdb: Thread/process failed: Thread died in Berkeley DB library</p>

<p>问题解决：#<br/>
01、删除yum临时库文件</p>

<p><code>rm -fr /var/lib/rpm/__db.*</code></p>

<p>02、重建rpm数据库</p>

<p><code>rpm --rebuilddb</code></p>

<p>03、清理缓存及生产yumdb缓存</p>

<p><code>yum clean all</code><br/>
<code>yum makecache</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux]]></title>
    <link href="http://565785929.github.io/15833368444152.html"/>
    <updated>2020-03-04T23:47:24+08:00</updated>
    <id>http://565785929.github.io/15833368444152.html</id>
    <content type="html"><![CDATA[
<p>Linux下的程序往往使你更加有效率，因为他们可以更高效的使用电脑的资源</p>

<p><strong>不同的Linux发行版之间的主要区别：</strong></p>

<p>1、安装方法不一样，有的复杂，有的简单。</p>

<p>2、安装应用程序的方式不一样。</p>

<p>3、预装的应用程序不一样。</p>

<h3 id="toc_0">linux发行版</h3>

<p>1、RedHat：性能稳定，老牌的linux发行版。收费的是RedHat Enterprise Linux（RHEL。redhat企业版）。目前RedHat分为两个系列：由RedHat公司提供收费技术支持。以及社区开发的免费的Fedora。</p>

<p>2、Fedora：RedHat的社区免费后继版，非常强大。</p>

<p>3、CentOS：国内许多企业选择CentOS，CentOS可以算是RHEL的克隆版，最大的好处就是免费。</p>

<p>4、SUSE：德国最著名的Linux发行版。</p>

<p>5、Debian：算是迄今为止，最遵循GNU规范的linux系统。（gnu的目标就是创建一套完全自由的操作系统。）</p>

<p>6、Ubuntu：Debian的后继一个分支。也是课程使用的linux发行版。</p>

<h3 id="toc_1">Ubuntu的优点</h3>

<p>1、简便易用。对于初学者，Ubuntu系统算是非常简单的，除了命令。</p>

<p>2、更新定期而频繁。每6个月就有一个新的Ubuntu版本，使用者非常多，支持的社区也很多。</p>

<p>3、标准化。</p>

<h3 id="toc_2">系统设置</h3>

<p><strong>lshw</strong>    获取硬件信息</p>

<p><strong>lscpu</strong>   获取CPU信息</p>

<p><strong>lsusb</strong>   获取usb接口信息</p>

<p><strong>uname</strong>   获取系统相关信息</p>

<p><strong>df</strong>  ：查看磁盘空间</p>

<p><strong>date</strong>    ：查看日期和时间</p>

<blockquote>
<p>&quot;+%j&quot; 今年中的第几天</p>
</blockquote>

<p><strong>hostname</strong>    ：显示主机名</p>

<p><strong>ifconfig</strong>    ：显示网络接口参数</p>

<h3 id="toc_3">关机重启命令</h3>

<p><strong>reboot</strong>  ：重启系统</p>

<p><strong>poweroff</strong>：   关机</p>

<p><strong>shutdown</strong>：   是定时关机</p>

<blockquote>
<p>shutdown -h time  指定时间，不写，就是一分钟之后执行</p>

<p>shutdown -h +5    ：五分钟后关机</p>

<p>shutdown -c   ：取消定时关机</p>

<p>shutdown -r now   ：立即重启</p>
</blockquote>

<h3 id="toc_4">常用指令</h3>

<pre class="line-numbers"><code class="language-python">#通过上下方向键来获取过往执行过的linux命令
#命令仅需输入前几位就可以用TAB键补全
要想准确，高效地完成各种任务，仅依赖命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数：
linux命令格式：
命令名称  [命令参数] [命令对象]
#命令名称、参数、对象之间用空格键分隔。

命令参数分为：
长格式  man --help
短格式  man -h

</code></pre>

<h3 id="toc_5">man 命令中常用按键以及用途</h3>

<table>
<thead>
<tr>
<th>按键</th>
<th>用处</th>
</tr>
</thead>

<tbody>
<tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>page down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>page up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>home（fn+左方向键）</td>
<td>直接前往首页</td>
</tr>
<tr>
<td>end（fn+右方向键）</td>
<td>直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td>从上至下搜索某个关键词，如 ‘/and’</td>
</tr>
<tr>
<td>?</td>
<td>从下至上搜索某个关键词，如 ‘？and’</td>
</tr>
<tr>
<td>n</td>
<td>定位到下一个搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td>定位到上一个搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td>退出帮助文档</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">目录命令</h3>

<p>1、pwd   ---print working directory</p>

<p>显示用户当前所处的工作目录</p>

<p>2、cd  ---change directory</p>

<p>用于切换工作路径</p>

<blockquote>
<p>cd 目录名  ：进入某一目录</p>

<p>cd ..    ：返回上一级目录，并显示路径</p>

<p>cd -   ：返回上一次所处的目录</p>

<p>cd ~     ：切换到当前用户的家目录</p>
</blockquote>

<p>3、ls ----list</p>

<p>ls会列举出当前工作目录的内容（文件或文件夹）</p>

<blockquote>
<p>-a    :查看所有文件（包括隐藏文件）</p>

<p>-l    ：查看文件的属性，大小等详细信息</p>
</blockquote>

<pre class="line-numbers"><code class="language-python">第一列一共十位：
#第一位是类型：
d代表目录
-代表是文件
l代表连接

#第二位到十位是权限
权限共九位，分三组，每三个一组
-rwx：
-r read 可读权限  4 或者 0
-w write 可写权限  2 或者 0  如果一条线，一个减号代表0
-x execute 可执行权限  1或者0

这三个字母能表示多少值:0-7
0：什么权限都没有
1：文件只能执行
2：文件只有写权限
3：文件可写可执行
4：文件只有读权限
5：可读可执行
6：可读可写
7：可读可写可执行

#对于文件而言：
可读权限表示允许读其内容，而禁止对其做任何的更改操作
可写权限表示可以改写编辑文件的内容或删除文件。（要有文件所在目录的写权限）
可执行权限表示允许将该文件作为一个程序执行。
#对于目录而言：
可读权限表示允许显示该目录中的内容
可写权限表示可以在目录中新建，删除，重名令文件
可执行权限表示可以进入该目录。可执行权限是基本权限。

权限共九位，每三个一组
1、代表当前用户的权限  ---读写和执行
2、代表当前用户所属的组的权限
3、代表其他组的权限

-w-


</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 开启自动驼峰转换]]></title>
    <link href="http://565785929.github.io/15826152154212.html"/>
    <updated>2020-02-25T15:20:15+08:00</updated>
    <id>http://565785929.github.io/15826152154212.html</id>
    <content type="html"><![CDATA[
<p>在mybatis-config.xml文件中加入此设置</p>
<?xml version="1.0" encoding="UTF-8" ?>
<p>&lt;!DOCTYPE configuration<br/><br/>
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;<br/><br/>
&quot;<a href="http://mybatis.org/dtd/mybatis-3-config.dtd%22%3E">http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</a><br/><br/>
<configuration><br/><br/>
    <settings><br/><br/>
        <setting name="mapUnderscoreToCamelCase" value="true" /><br/><br/>
    </settings><br/><br/>
</configuration></p>

<p><img src="media/15826152154212/15826153307445.jpg" alt=""/></p>

<p>参考:<br/>
<a href="https://yq.aliyun.com/articles/662319">https://yq.aliyun.com/articles/662319</a><br/>
<a href="https://www.cnblogs.com/pjfmeng/p/7677773.html">https://www.cnblogs.com/pjfmeng/p/7677773.html</a><br/>
<a href="https://www.cnblogs.com/zhouricong/p/9483099.html">https://www.cnblogs.com/zhouricong/p/9483099.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java和mysql转换]]></title>
    <link href="http://565785929.github.io/15823891714442.html"/>
    <updated>2020-02-23T00:32:51+08:00</updated>
    <id>http://565785929.github.io/15823891714442.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th>java类</th>
<th> </th>
<th>mysql数据库</th>
</tr>
</thead>

<tbody>
<tr>
<td>java.lang.Byte</td>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>java.lang.Short</td>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>java.lang.Integer</td>
<td>integer</td>
<td>INGEGER</td>
</tr>
<tr>
<td>java.lang.Long</td>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>java.lang.Float</td>
<td>float</td>
<td>FLOAT</td>
</tr>
<tr>
<td>java.lang.Double</td>
<td>double</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>java.lang.BigDecimal</td>
<td>big_decimal</td>
<td>NUMERIC</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>java.lang.String</td>
<td>string</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>yes_no</td>
<td>CHAR(1)(&#39;Y&#39;或&#39;N&#39;)</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>true_false</td>
<td>CHAR(1)(‘Y’或&#39;N&#39;)</td>
</tr>
<tr>
<td>java.uitl.Date</td>
<td>java.sql.Date</td>
<td>date</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.uitl.Calendar</td>
<td>celendar</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.uitl.Calendar</td>
<td>calendar</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>java.io.Serializable</td>
<td>serializable</td>
<td>VARBINARY/BLOB</td>
</tr>
<tr>
<td>java.sql.Clob</td>
<td>clob</td>
<td>CLOB</td>
</tr>
<tr>
<td>java.sql.Blob</td>
<td>blob</td>
<td>BLOB</td>
</tr>
<tr>
<td>java.lang.Class</td>
<td>class</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.Locale</td>
<td>locale</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.TimeZone</td>
<td>timezone</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>java.uitl.Currency</td>
<td>currency</td>
<td>VARCHAR</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 查看表注释或字段注释]]></title>
    <link href="http://565785929.github.io/15823882245344.html"/>
    <updated>2020-02-23T00:17:04+08:00</updated>
    <id>http://565785929.github.io/15823882245344.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">查看注释</h2>

<p>查看所有表的注释</p>

<pre class="line-numbers"><code class="language-sql">SELECT
table_name 表名,
table_comment 表说明
FROM
information_schema.TABLES
WHERE
table_schema = &#39;数据库名&#39;
ORDER BY
table_name
</code></pre>

<p>查询所有表及字段的注释</p>

<pre class="line-numbers"><code class="language-sql">SELECT
a.table_name 表名,
a.table_comment 表说明,
b.COLUMN_NAME 字段名,
b.column_comment 字段说明,
b.column_type 字段类型,
b.column_key 约束
FROM
information_schema.TABLES a
LEFT JOIN information_schema.COLUMNS b ON a.table_name = b.TABLE_NAME
WHERE
a.table_schema = &#39;数据库名&#39;
ORDER BY
a.table_name
</code></pre>

<p>查询某表的所有字段的注释</p>

<pre class="line-numbers"><code class="language-sql">select 
COLUMN_NAME 字段名,
column_comment 字段说明,
column_type 字段类型,
column_key 约束 from information_schema.columns 
where table_schema = &#39;数据库名&#39;
and table_name = &#39;表名&#39; ; 
</code></pre>

<p>或者</p>

<pre class="line-numbers"><code class="language-sql">show full columns from 表名;
</code></pre>

<h2 id="toc_1">查看表生成的DDL</h2>

<p><strong>注意表名不加单引号</strong></p>

<pre class="line-numbers"><code class="language-sql">show create table 表名;
</code></pre>

<h2 id="toc_2">新建表以及添加表和字段的注释</h2>

<pre class="line-numbers"><code class="language-sql">create table t_user(
    ID INT(19) primary key auto_increment  comment &#39;主键&#39;,
    NAME VARCHAR(300) comment &#39;姓名&#39;,
    CREATE_TIME date comment &#39;创建时间&#39;
)comment  = &#39;用户信息表&#39;;
</code></pre>

<h2 id="toc_3">修改表/字段的注释</h2>

<p>修改表注释</p>

<pre class="line-numbers"><code class="language-sql">alter table t_user comment  = &#39;修改后的表注释信息(用户信息表)&#39;;
</code></pre>

<p>修改字段注释</p>

<pre class="line-numbers"><code class="language-sql">alter table t_user modify column id int comment &#39;主键ID&#39;;
</code></pre>

<p>参考：简书<a href="https://www.jianshu.com/p/e6286174d35c">Mysql 查看表注释或字段注释</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易云 最嗨电音 爬虫]]></title>
    <link href="http://565785929.github.io/15819525546014.html"/>
    <updated>2020-02-17T23:15:54+08:00</updated>
    <id>http://565785929.github.io/15819525546014.html</id>
    <content type="html"><![CDATA[
<p>抓手机包找到音乐链接 Size最大</p>

<p><img src="media/15819525546014/15819533512601.jpg" alt="" style="width:1062px;"/></p>

<p>贴到浏览器发现可以打开，确实为此音乐</p>

<p><img src="media/15819525546014/15819534156184.jpg" alt="" style="width:546px;"/></p>

<p>筛选所有音乐链接 <code>m\d.music.126.net</code><br/>
<img src="media/15819525546014/15819537374098.jpg" alt="" style="width:1152px;"/></p>

<p>积攒一段时间，将这些链接拷贝到文件里<br/>
<img src="media/15819525546014/15819535577751.jpg" alt="" style="width:973px;"/></p>

<p>编写Python代码，统一下载</p>

<pre class="line-numbers"><code class="language-python">import requests
from urllib import request


class Electronic:

    def __init__(self) -&gt; None:
        self.s = requests.session()
        self.dir = &quot;music/&quot;
        self.file = &quot;music.txt&quot;

    def open_file(self):
        with open(self.file, &#39;r&#39;) as f:
            for number, line in enumerate(f, start=1):
                yield line

    def get_music(self, url, name):
        try:
            self.s.get(url)
            request.urlretrieve(url, name)
        except Exception as ex:
            print(url, ex)

    def start(self):
        for url in self.open_file():
            print(url)
            name = url.split(&#39;/&#39;)[-1].strip()
            self.get_music(url, self.dir + name)


if __name__ == &#39;__main__&#39;:

    e = Electronic()
    e.start()

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cheat.sh]]></title>
    <link href="http://565785929.github.io/15802234606202.html"/>
    <updated>2020-01-28T22:57:40+08:00</updated>
    <id>http://565785929.github.io/15802234606202.html</id>
    <content type="html"><![CDATA[
<p>cheat是在GNU通用公共许可证下，为Linux命令行用户发行的交互式备忘单应用程序。简单来说，它没有提供其他额外多余的信息，只通过使用实例告诉你一个命令参数如何使用。</p>

<h2 id="toc_0">使用</h2>

<p>它无需安装，提供网络查询方式，要从命令行获取UNIX / Linux命令的备忘单，请使用curl或任何其他在查询中指定命令名称的HTTP / HTTPS客户端来查询服务：</p>

<pre class="line-numbers"><code class="language-bash">    curl cheat.sh/tar
    curl cht.sh/curl
    curl https://cheat.sh/rsync
    curl https://cht.sh/tr
</code></pre>

<h2 id="toc_1">安装</h2>

<p>想离线使用，也可以安装客户端，非常简单<br/>
To install the client:</p>

<pre class="line-numbers"><code class="language-bash">    mkdir -p ~/bin/
    curl https://cht.sh/:cht.sh &gt; ~/bin/cht.sh
    chmod +x ~/bin/cht.sh
</code></pre>

<p>or to install it globally (for all users):</p>

<pre class="line-numbers"><code class="language-bash">    curl https://cht.sh/:cht.sh | sudo tee /usr/local/bin/cht.sh
    sudo chmod +x /usr/local/bin/cht.sh
</code></pre>

<p>之后也可以给cht.sh创建一个别名</p>

<p>client: <code>vi ~/.bashrc</code><br/>
globally: <code>sudo vi /etc/profile</code></p>

<p>在最后添加</p>

<pre class="line-numbers"><code class="language-text"># cheat
alias cht=cht.sh
</code></pre>

<p>重新加载一下配置文件<br/>
client: <code>source ~/.bashrc</code><br/>
globally: <code>source /etc/profile</code></p>

<p>之后可以使用cht获取命令示例<br/>
<img src="media/15802234606202/15802244400106.jpg" alt="" style="width:682px;"/></p>

<p>如果输出的不是你需要的答案，你可以选择带入参数， 例如/1, /2 :</p>

<pre class="line-numbers"><code class="language-text">    curl cht.sh/python/random+string
    curl cht.sh/python/random+string/1
    curl cht.sh/python/random+string/2
</code></pre>

<p><a href="https://github.com/chubin/cheat.sh">github</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crontab 定时任务]]></title>
    <link href="http://565785929.github.io/15776732342055.html"/>
    <updated>2019-12-30T10:33:54+08:00</updated>
    <id>http://565785929.github.io/15776732342055.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Linux</h3>

<p><img src="media/15776732342055/15776733247221.jpg" alt="" style="width:634px;"/></p>

<p>crontab -e <br/>
打开编辑表达式</p>

<p>表达式必须使用绝对路径</p>

<p>sudo systemctl restart crond.service<br/>
重启生效</p>

<p>crontab -l<br/>
查看所有定时任务表达式</p>

<h3 id="toc_1">cht</h3>

<p><img src="media/15776732342055/15826461147316.jpg" alt="" style="width:767px;"/></p>

<pre class="line-numbers"><code class="language-bash">&gt; cht crontab
# crontab
# Schedule cron jobs to run on a time interval for the current user.
# Job definition format: &quot;(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute&quot;.

# Edit the crontab file for the current user:
crontab -e

# Edit the crontab file for a specific user:
sudo crontab -e -u user

# View a list of existing cron jobs for current user:
crontab -l

# Remove all cron jobs for the current user:
crontab -r

# Sample job which runs at 10:00 every day (* means any value):
0 10 * * * command_to_execute

# Sample job which runs every minute on the 3rd of April:
* * 3 Apr * command_to_execute

# Sample job which runs a certain script at 02:30 every Friday:
30 2 * * Fri /absolute/path/to/script.sh
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[监控Python 运行]]></title>
    <link href="http://565785929.github.io/15773499726644.html"/>
    <updated>2019-12-26T16:46:12+08:00</updated>
    <id>http://565785929.github.io/15773499726644.html</id>
    <content type="html"><![CDATA[
<p>使用memory_profiler模块</p>

<p>memory_profiler模块用来基于逐行测量代码的内存使用。使用这个模块会让代码运行的更慢。</p>

<p>安装方法如下：<br/>
<code>pip install memory_profiler</code></p>

<p>另外，建议安装psutil包，这样memory_profile会运行的快一点：<br/>
<code>pip install psutil</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh]]></title>
    <link href="http://565785929.github.io/15769921068601.html"/>
    <updated>2019-12-22T13:21:46+08:00</updated>
    <id>http://565785929.github.io/15769921068601.html</id>
    <content type="html"><![CDATA[
<p>systemctl stop sshd.service <br/>
停止转发</p>

<p>lsof -i :80|grep -v &quot;PID&quot;|awk &#39;{print &quot;kill -9&quot;,$2}&#39;|sh<br/>
关闭80端口程序</p>

<p>pscp -r -l root -pw 5657 e:\htk 118.24.163.26:/root<br/>
e:\htk -&gt; /root 传送文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pscp]]></title>
    <link href="http://565785929.github.io/15769920752565.html"/>
    <updated>2019-12-22T13:21:15+08:00</updated>
    <id>http://565785929.github.io/15769920752565.html</id>
    <content type="html"><![CDATA[
<p>远程传输命令 </p>

<p>pscp和scp功能相同，但pscp同时支持windows下使用，它有效解 决了windows系统向linux服务器传输文件，而且它只有一个文件，即pscp.exe，建议将该文件放到C:\WINDOWS\system32 下面，这样就可以在任何地方调用该文件命令，你也可以放在任意你指定文件夹下。</p>

<p><img src="media/15769920752565/15802251740483.jpg" alt="" style="width:682px;"/></p>

<ol>
<li>环境变量改好后，在命令行下输入 pscp就可以拷文件了：</li>
</ol>

<p>命令格式：pscp localfile rootuser@remoteip:/fileDirectory</p>

<p>拷贝整个文件夹： pscp -r localDir rootuser@remoteip:/fileDirectory</p>

<p>如果是从linux拷贝文件，是同样的方法，只不过是把前后地址对换一下即可;</p>

<ol>
<li>比如我想把windows下e:\htk 整个目录的所有文件复制到linux /root目录下，命令如下：</li>
</ol>

<p><strong>pscp -r -l root -pw 1234567890 e:\htk 192.168.0.204:/root</strong></p>

<p>说明：</p>

<p>-r 复制目录下所有文件;</p>

<p>-l 对方机器(linux)的用户名(root);</p>

<p>-pw 密码(1234567890 );</p>

<p>e:\htk 源文件/文件夹的地址;</p>

<p>192.168.0.204:/root 目的文件/文件夹的地址。192.168.0.204为linux机器的ip地址。</p>

<ol>
<li>反过来，把linux soundRcg目录下的test.txt文件传输到windows e:\下，同样在windows命令行中敲入命令： </li>
</ol>

<p>*<em>pscp -l root -pw 1234567890 192.168.0.204:/soundRcg/test.txt E:*</em></p>

<p>备注：pscp似乎传输速度不是很快。</p>

<p>lsof -i :80|grep -v &quot;PID&quot;|awk &#39;{print &quot;kill -9&quot;,$2}&#39;|sh</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git]]></title>
    <link href="http://565785929.github.io/15769919595310.html"/>
    <updated>2019-12-22T13:19:19+08:00</updated>
    <id>http://565785929.github.io/15769919595310.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Git是分布式版本控制系统 自报家门</h3>

<p>git config --global user.name &quot;Sajor&quot;<br/>
git config --global user.email &quot;<a href="mailto:565785929@qq.com">565785929@qq.com</a>&quot;</p>

<h2 id="toc_1">一</h2>

<p>初始化一个Git仓库，使用git init命令。</p>

<p>添加文件到Git仓库，分两步：</p>

<p>第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；</p>

<p>第二步，使用命令git commit，完成。</p>

<h3 id="toc_2">windows中的换行符为 CRLF， 而在linux下的换行符为LF，所以在执行add . 时出现提示，解决办法：</h3>

<pre class="line-numbers"><code class="language-text">rm -rf .git  // 删除.git  
git config --global core.autocrlf false  //禁用自动转换    

git init    // 重新执行
git add .  
</code></pre>

<h3 id="toc_3">文件添加到仓库 add</h3>

<pre class="line-numbers"><code class="language-text">git add readme.txt     // filename = readme.txt
</code></pre>

<h3 id="toc_4">用命令 git commit 告诉Git 文件提交到仓库</h3>

<pre class="line-numbers"><code class="language-text">git commit -m &quot;wrote a readme file&quot; 
-m后面输入的是本次提交的说明
commit可以一次提交很多文件，所以你可以多次add不同的文件
</code></pre>

<hr/>

<h2 id="toc_5">二</h2>

<p>要随时掌握工作区的状态，使用git status命令。</p>

<p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p>

<h3 id="toc_6">git status 查看当前状态</h3>

<pre class="line-numbers"><code class="language-text">git status 
</code></pre>

<h3 id="toc_7">git diff 查看做了哪些修改</h3>

<pre class="line-numbers"><code class="language-text">git diff readme.txt    // filename = readme.txt
git diff    #是工作区(work dict)和暂存区(stage)的比较
git diff --cached    #是暂存区(stage)和分支(master)的比较（add之后）
</code></pre>

<hr/>

<h2 id="toc_8">三</h2>

<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>

<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>

<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>

<h3 id="toc_9">git log 显示从最近到最远的提交日志</h3>

<pre class="line-numbers"><code class="language-text">git log 
// --pretty=oneline参数 可以在一行显示
git log --pretty=oneline 
前面的是commit id（版本号）
</code></pre>

<h3 id="toc_10">回退版本</h3>

<pre class="line-numbers"><code class="language-text">git reset -- hard HEAD^  
// 上一个版本是HEAD^ , 上上一个版本就是HEAD^^, 往上100个是HEAD~100
</code></pre>

<h3 id="toc_11">再返回未来的版本可以用commit id 返回</h3>

<pre class="line-numbers"><code class="language-text">git reset --hard 3628164  // commit id = 3628164
</code></pre>

<h3 id="toc_12">git reflog 记录你的每一次命令</h3>

<pre class="line-numbers"><code class="language-text">git reflog  前面会加你的commit id
</code></pre>

<hr/>

<h2 id="toc_13">四</h2>

<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</p>

<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>

<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>

<p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>

<h3 id="toc_14">撤销工作区的修改</h3>

<pre class="line-numbers"><code class="language-text">git checkout -- readme.txt   // filename = readme.txt
</code></pre>

<h3 id="toc_15">撤销缓存区的提交</h3>

<pre class="line-numbers"><code class="language-text">git reset HEAD readme.txt   // filename = readme.txt
</code></pre>

<h3 id="toc_16">工作区删除</h3>

<pre class="line-numbers"><code class="language-text">rm test.txt
</code></pre>

<h3 id="toc_17">从版本库中删除该文件 git rm 删掉 并提交</h3>

<pre class="line-numbers"><code class="language-text">git rm test.txt    // filename = test.txt
git commit -m &quot;remove test.txt&quot;
</code></pre>

<h3 id="toc_18">也可以使用 git checkout 恢复</h3>

<pre class="line-numbers"><code class="language-text">git checkout -- test.txt
</code></pre>

<hr/>

<h2 id="toc_19">五</h2>

<p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>

<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>

<p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>

<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>

<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br/>
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>

<h3 id="toc_20">在GitHub 添加ssh秘钥</h3>

<pre class="line-numbers"><code class="language-text">ssh-keygen -t rsa    生成ssh秘钥 
cat C://Users/zzx/.ssh/id_rsa.pub   默认位置
</code></pre>

<h3 id="toc_21">推送到远程仓库</h3>

<pre class="line-numbers"><code class="language-text">git remote add origin git@github.com:565785929/learngit.git
git push -u origin master
</code></pre>

<h3 id="toc_22">本地做了提交再更新远程仓库</h3>

<pre class="line-numbers"><code class="language-text">git push origin master 
</code></pre>

<h3 id="toc_23">远程库已经准备好了 git clone克隆一个本地库</h3>

<pre class="line-numbers"><code class="language-text">git clone git@github.com:565785929/gitskills.git     // proname = gitskills
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币]]></title>
    <link href="http://565785929.github.io/15769918912350.html"/>
    <updated>2019-12-22T13:18:11+08:00</updated>
    <id>http://565785929.github.io/15769918912350.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">EC私钥 Elliptic Curve private key</h3>

<p>比特币私钥为一个256位的二进制随机大数 一共32字节（Random 256 bit integer）</p>

<p>比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。 </p>

<p>将256位二进制大数转为十六进制（每四位二进制数转为一位十六进制数）得到一个64位的十进制字符串，这就是ec私钥（95e7e1e73b70965d31c3e56121ce14dd4f88431c8d5e7645e8fb4a73ba72ad29）</p>

<p>提示比特币私钥空间的大小是2<sup>256，这是一个非常大的数字。用十进制表示的话，大约是10<sup>77，而可见宇宙被估计只含有10<sup>80个原子。</sup></sup></sup></p>

<h3 id="toc_1">WIF格式私钥 Wallet import format</h3>

<p>私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。不同的格式用在不同的场景下。十六进制和原始的二进制格式用在软件的内部，很少展示给用户看。WIF格式用在钱包之间密钥的输入和输出，也用于代表私钥的二维码（条形码）。</p>

<p>ec私钥转换成wif格式私钥需要经过以下几个步骤<br/>
主网： 在ec私钥前面添加版本号x80，再经过base58check。生成的字符串由5开头<br/>
测试网： 在ec私钥前面添加版本号xEF，再经过base58check。生成的字符串由9开头</p>

<h3 id="toc_2">WIF-compressed格式私钥</h3>

<p>现在广泛使用这种私钥，表示比特币地址是由压缩公钥生成的。故也成为“压缩格式私钥”，<br/>
实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包， 只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式 是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</p>

<p>ec私钥转换成wif-compressed格式私钥需要经过以下几个步骤<br/>
主网： 在ec私钥前面添加版本号x80，后面添加x01,再经过base58check。 生成的字符串由K或L开头<br/>
测试网： 在ec私钥前面添加版本号xEF，后面添加x01,再经过base58check。 生成的字符串由c开头</p>

<h1 id="toc_3">公钥</h1>

<p>公钥由私钥经过secp256k1椭圆曲线算法生成。<br/>
公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。<br/>
我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头。</p>

<h3 id="toc_4">普通公钥</h3>

<p>经过椭圆曲线加密算法生成一个（x, y）的坐标，公钥就是两个坐标点连接形成的字符串。</p>

<h3 id="toc_5">压缩公钥</h3>

<p>引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭据和支付比特币。每个公钥有520比特（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。</p>

<p>一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2 mod p = (x3 + 7) mod p得到y坐 标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所 需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。</p>

<p>未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲 线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在 x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。</p>

<h1 id="toc_6">比特币地址</h1>

<p>地址为公钥的hash， 因为有压缩和未压缩的公钥两种格式，所以同一个私钥可以生成两个不同的公钥，两个不同的公钥可以推出两个不用的比特币地址，但是它们对应的私钥却是相同的。</p>

<h1 id="toc_7">总结</h1>

<p><img src="media/15769918912350/bitcoin_address.jpg" alt="bitcoin_address"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[brew update 缓慢]]></title>
    <link href="http://565785929.github.io/15765692780377.html"/>
    <updated>2019-12-17T15:54:38+08:00</updated>
    <id>http://565785929.github.io/15765692780377.html</id>
    <content type="html"><![CDATA[
<p>更新时 使用 --verbose命令可以看到运行情况</p>

<p><code>brew update --verbose</code></p>

<p>查看brew的当前源:<br/>
执行下面命令可以看到, brew的官方镜像源为: <a href="https://github.com/Homebrew/homebrew">https://github.com/Homebrew/homebrew</a></p>

<pre class="line-numbers"><code class="language-text">cd /usr/local/Homebrew
git remote -v
</code></pre>

<p>更改brew镜像源</p>

<pre class="line-numbers"><code class="language-text">cd /usr/local/Homebrew
git remote set-url origin git://mirrors.tuna.tsinghua.edu.cn/homebrew.git
</code></pre>

<p>可以选择下面镜像源中的一个 (第一个亲测可用)<br/>
清华镜像源: git://mirrors.tuna.tsinghua.edu.cn/homebrew.git<br/>
中科大镜像源: <a href="http://mirrors.ustc.edu.cn/homebrew.git">http://mirrors.ustc.edu.cn/homebrew.git</a></p>

<h2 id="toc_0">mirrors.tuna.tsinghua.edu.cn[0: 101.6.8.193]: errno=Operation timed out</h2>

<p>Homebrew 镜像使用帮助<br/>
注:该镜像是 Homebrew 的 formula 索引的镜像（即 brew update 时所更新内容）。本镜像站同时提供 Homebrew 二进制预编译包的镜像</p>

<p>替换现有上游</p>

<pre class="line-numbers"><code class="language-text">cd &quot;$(brew --repo)&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git
 
cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git
 
brew update
</code></pre>

<p>使用homebrew-science或者homebrew-python</p>

<pre class="line-numbers"><code class="language-text">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-science&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-science.git
 
cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-python&quot;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-python.git
 
brew update
</code></pre>

<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a></p>

<p><a href="https://blog.csdn.net/poem_2010/article/details/85049044">https://blog.csdn.net/poem_2010/article/details/85049044</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis使用场景]]></title>
    <link href="http://565785929.github.io/15754473183515.html"/>
    <updated>2019-12-04T16:15:18+08:00</updated>
    <id>http://565785929.github.io/15754473183515.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">缓存数据</h2>

<p>最常用，对经常需要查询且变动不是很频繁的数据</p>

<h2 id="toc_1">排行榜应用</h2>

<p>利用Redis的有序集合zset，每次插入数据时自动调整顺序值，根据插入时的score值将value按一定顺序连续排列。</p>

<h2 id="toc_2">计数器应用</h2>

<p>利用Redis的incr、decr命令进行原子性操作，来构建计数系统<br/>
比如在一个web应用程序中，如果想知道用户在一年中每天的点击量，只要将用户id和相关日期信息作为键，并在每次用户点击页面时，执行一次自增操作即可。</p>

<h2 id="toc_3">数据去重</h2>

<p>当需要存储一个列表数据，又不希望出现重复数据时，可以使用Redis的Set数据结构<br/>
set内部实现是一个value永远是null的hashmap，通过hash计算的方式判断一个成员是否在集合内，从而进行快速排重。</p>

<h2 id="toc_4">队列应用</h2>

<p>使用Redis的list类型的lpush、rpop、lpop可实现</p>

<p><a href="https://mp.weixin.qq.com/s/No0YW65zLQ9Pq25ynqSzgQ">https://mp.weixin.qq.com/s/No0YW65zLQ9Pq25ynqSzgQ</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自建redis集群规范]]></title>
    <link href="http://565785929.github.io/15754418238619.html"/>
    <updated>2019-12-04T14:43:43+08:00</updated>
    <id>http://565785929.github.io/15754418238619.html</id>
    <content type="html"><![CDATA[
<ul>
<li>可靠性低：如果数据走云盘做高可靠存储容易受网络波动干扰，如果不走云盘宕机数据易丢失，自建多副本运维很复杂，而且Redis本身的断网导致的全量同步机制对网络和运维的要求极高；</li>
<li>可用性低：自建单副本无法保证可用性，多副本对心跳检查和链路切换要求极高，传统的sentinel有很多缺陷，在执行复杂的keys flushdb等命令时很容易造成误切和雪崩；</li>
<li>诸多限制：自建集群方案如redis cluster，codis也有诸多限制，redis cluster需要smart client和非常</li>
</ul>

<h2 id="toc_0">键值设计</h2>

<p>key名设计</p>

<p>可读性和可管理性</p>

<p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p>

<p>ugc:video:1</p>

<p>简洁性</p>

<p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p>

<p>user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。<br/>
不要包含特殊字符</p>

<p>反例：包含空格、换行、单双引号以及其他转义字符</p>

<p><a href="https://www.cnblogs.com/-wenli/p/10941249.html">完整阿里云Redis开发规范</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis 集群]]></title>
    <link href="http://565785929.github.io/15754270430043.html"/>
    <updated>2019-12-04T10:37:23+08:00</updated>
    <id>http://565785929.github.io/15754270430043.html</id>
    <content type="html"><![CDATA[
<p>首先安装redis<br/>
brew install redis</p>

<p>将/usr/local/redis/bin<br/>
建立redis-cluster文件夹，复制六份， 三主三备份， 分别叫redis01-redis-06<br/>
<img src="media/15662634729470/15663492850811.jpg" alt="" style="width:423px;"/></p>

<p>将每个文件夹中的redis.conf都修改一下<br/>
例如： redis01/redis.conf</p>

<pre class="line-numbers"><code class="language-text">port 7001

cluster-enabled yes

cluster-config-file  nodes_7001.conf  

cluster-node-timeout  15000 

pidfile  /var/run/redis_7001.pid
</code></pre>

<p>redis02-redis06 的配置文件参照01的配置，将其中7001都改为2-6即可。</p>

<p>编写bash脚本启动</p>

<pre class="line-numbers"><code class="language-text">./redis01/redis-server ./redis01/redis.conf
./redis02/redis-server ./redis02/redis.conf
./redis03/redis-server ./redis03/redis.conf
./redis04/redis-server ./redis04/redis.conf
./redis05/redis-server ./redis05/redis.conf
./redis06/redis-server ./redis06/redis.conf
</code></pre>

<p>运行后查看进程<br/>
ps -ef | grep redis<br/>
<img src="media/15662634729470/15663495776677.jpg" alt="" style="width:707px;"/></p>

<p>安装ruby<br/>
brew install ruby</p>

<p>到rubypems.org下载redis工具，也可以直接wget<br/>
brew install wget<br/>
wget <a href="http://rubygems.org/downloads/redis-3.3.0.gem">http://rubygems.org/downloads/redis-3.3.0.gem</a><br/>
gem install -l redis-3.3.0.gem</p>

<p>创建集群</p>

<pre class="line-numbers"><code class="language-text">./redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1
</code></pre>

<p>报错</p>

<blockquote>
<p>[ERR] Node 127.0.0.1:7001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.</p>
</blockquote>

<p>连接到每个redis 运行</p>

<p>flushdb</p>

<blockquote>
<p>Node is not empty</p>
</blockquote>

<p>运行fix</p>

<p>./redis-cli --cluster fix 127.0.0.1:7001</p>

<p>cluster命令</p>

<pre class="line-numbers"><code class="language-text">cluster info 
cluster nodes
</code></pre>

<p>参考：<a href="https://blog.csdn.net/qq_42815754/article/details/82912130">redis集群搭建（非常详细，适合新手）</a><br/>
<a href="https://www.jianshu.com/p/dfc6656d4287">Redis 5.0.3集群搭建</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux安全查找原因]]></title>
    <link href="http://565785929.github.io/15753573808254.html"/>
    <updated>2019-12-03T15:16:20+08:00</updated>
    <id>http://565785929.github.io/15753573808254.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">备份重要命令</h3>

<p>高手入侵可能会修改集群中的重要命令，例如：top、ps、kill等重要命令<br/>
建议备份好</p>

<p><a href="https://blog.csdn.net/xinxin_2011/article/details/84936581">Linux系统发现占用CPU达100%的进程并处理</a></p>

]]></content>
  </entry>
  
</feed>
